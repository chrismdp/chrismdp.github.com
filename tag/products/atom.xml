---
layout: nil
---
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Chris Parsons: posts tagged products</title>

  <link href="http://chrismdp.com/"/>
  <updated>2012-09-21T13:25:13+01:00</updated>
  <id>http://chrismdp.com/tag/products</id>
  <author>
    <name>Chris Parsons</name>
    <email>chrismdp@gmail.com</email>
  </author>
<entry><title>Introducing Morning Pages</title><category term='life'/><category term='writing'/><category term='personal'/><category term='products'/><category term='productivity'/><link href='http://chrismdp.com/2012/09/introducing-morning-pages'/><updated>2012-09-21T13:25:13+01:00</updated><id>http://chrismdp.com/2012/09/introducing-morning-pages</id><content type='html'>I've [written before](/2010/07/seven-hundred-and-fifty-words) about the value of Morning Pages - a way of clearing your head in the mornings by writing down three pages on everything you're thinking and feeling.

In order to write my words, I used [750words.com](http://750words.com) for a number of years, but I've become a little disenfranchised with having private writings stored permanently in the cloud. I also write fastest in vim, which means writing into a website slows me down. What I really wanted was to store my words privately on my laptop, and yet also include a public incentive system: this is what made 750words.com so effective at keeping me motivated.

## gem install morning-pages

The result is the morning-pages gem. The gem has been available for a while, but starting today it'll record your progress on a central website. It only ever uploads aggregate statistics: the code is [open source](http://github.com/chrismdp/morning-pages) so you can check it out for yourself to make sure.

For instructions, see the [accompanying website](http://morning-pages.me). There aren't any aggregate stats yet, but in future you'll be able to see any word streaks, what times of day you are most likely to write, etc. I've got some nice ideas for visualisation which I'll add as time permits: if you're impatient you can always [fork the website code](http://github.com/chrismdp/morning-pages.me) and create whatever stats you want!

## What do I use my words for?

Writing three pages is still something I try and do each day: I had a 170 day streak going at one point. I use my words to plan and order my day, to negotiate with myself about what I can realistically achieve, and [for prayer and meditation](http://en.wikipedia.org/wiki/Christian_meditation) - I've found I pray best at the point of a metaphorical pen.

Do you try to write each day? What do you use your words for?
</content></entry><entry><title>Showroom software</title><category term='products'/><category term='business'/><category term='lean'/><link href='http://chrismdp.com/2012/09/showroom-software'/><updated>2012-09-17T20:34:12+01:00</updated><id>http://chrismdp.com/2012/09/showroom-software</id><content type='html'>I went to IKEA recently to buy some more furniture for my office. Whilst wandering around trying to find the desk I wanted, I happened across a one-bedroom showroom apartment. The designers of this apartment had spent a lot of time and effort getting the most out of very limited space: so much so that they had fitted this entire home, including shower room, kitchenette, dining table, lounge with sofa bed and wardrobe storage into only &lt;i&gt;25 square metres.&lt;/i&gt;

Think about that for a second. That's five metres by five metres. It's an extroadinarily small space to fit in a whole home, but they had managed it. What's more, it looked great! Everything was set up perfectly: you felt as if you could just move in there and then.

## The problem

There's a problem with this kind of apartment though: *what would happen if you actually tried to recreate that exact layout in your own 25 square metre apartment?* If you went around the IKEA version and painstakingly wrote down all of the different pieces of furniture you'd need, loaded them into a van and took them home, you'd invariably find they wouldn't fit. You'd want to make some small changes here and there, which would unavoidably have knock-on effects in such a small space. You'd end up taking half of the furniture back as you couldn't use it. Uneven walls, annoyingly placed sockets and irksome light fittings would make a mess of the finely crafted design.

So what's the best way to fill a real apartment of this size? *Plan the furniture based around the exact contours of the apartment,* rather than trying to fit the apartment round the furniture. Better still, get in someone who knows what they're doing to help you. Buy as little furniture as possible and work with the space you have.

## &quot;Off the shelf&quot; software is a showroom

Buying software is a little like this. Whether you're a startup or an existing business, it's tempting to buy an off the shelf solution to solve all your problems. It seems so easy, and the vendors often promise so much. It's like the beautiful showroom apartment: it's affordable, it all fits together so beautifully, and you can start using it straight away.

This can work when the problem is well defined, you have a truly blank slate, or the software is just one piece of the puzzle, but most businesses are rougher round the edges that off the shelf software would like. The solution you've just purchased is never a solution to your specific problem: it's a general solution to the problem the vendor thought you would have a few months or years ago when they thought up the product. Inevitably the solution is for a slightly different problem to the one you have now. In the case of startups, which don't even know what the problem they're trying to solve is yet, they can be constrained by off the shelf software extremely quickly.

What can end up happening is one of two things:

* *You fit your business around the software.* Your business processes become trapped in the workings of the software you're using, making your business less able to respond to change in the market. This is a dangerous situation for any business to be in.

* *You shoehorn the software into your business.* You hire the vendor to customise the software for you, or you attempt to do it yourself. With a well written off the shelf system this may have some mileage. However, the danger is that the total cost ends up being a lot higher than you bargained for, and the system becomes a grostesque elephantine mess which only just hangs together.

## A potential alternative

What's the alternative? You could investigate building something that fits your business exactly. Bespoke software isn't always the best solution: it's always a trade off. However, I'd suggest always getting advice from a bespoke software developer before spending large amounts on any off the shelf system. A great developer should always help you spend as little as possible to get what you want, so your total cost might be less than you think.

*The same is true for startups.* If your budget is really constrained, how about building something really small from scratch, pulling together as much existing code as possible? Don't reinvent the wheel - to extend the showroom analogy, that would be like building your own furniture from raw materials - but don't assume an off the shelf piece of software will run 90% of your business for you just the way you want it to.

So for any moderately complex business problem, be careful of off-the-shelf one-size-fits-all &quot;it'll do everything you want for a fraction of the price!&quot; software products. Next time you make a decision like this, get some advice, and ask yourself whether you're purchasing the beautiful showroom apartment, and then trying to shoehorn it in to a place that it's never going to fit.
</content></entry><entry><title>Attempting validated learning with Sol Trader</title><category term='sol trader'/><category term='lean startup'/><category term='learning'/><category term='products'/><category term='agile'/><category term='lean'/><category term='business'/><link href='http://chrismdp.com/2012/05/attempting-validated-learning-with-sol-trader'/><updated>2012-05-14T10:18:47+01:00</updated><id>http://chrismdp.com/2012/05/attempting-validated-learning-with-sol-trader</id><content type='html'>&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;.
&lt;/div&gt;

Sol Trader has been out just about two weeks now. It's been great fun to actually launch the product and gain real feedback from people.

*I've sold about forty copies.* It's a start, and a really good one. Thank you to those of you who have already purchased the game, and for all the feedback and encouraging emails I've received. I've learnt a huge amount already and it's really helped me guide the way ahead.

The big question is: what's next? How do I go from these humble yet encouraging beginnings to turning this game into something truly wonderful?

## Validated learning

I've read Eric Ries' excellent book [The Lean Startup](http://lean.st/) recently. In it he introduces a concept called [Validated learning](http://lean.st/principles/validated-learning) and goes on to define learning as the one important progress metric of startups: much more important than 'customer numbers' or 'features'. Rather than define startups purely by 'profit' or 'growth figures', how can we ensure that we're learning about how our business as fast as possible?

For Sol Trader, there are two main things that I need to find out.

* How can I ensure that I'm creating a game that people want to play, want to come back to, and want to tell their friends about?
* How can I ensure a steady stream of new players for the game?

## The Sol Trader Hypothesis board

In order to support this learning, I've created the Sol Trader hypothesis progress chart:

![Sol Trader hypotheses chart](/files/sol-trader-hypotheses-chart.png)

This is what I'm using to track my theories. A good week would be one where I've managed to prove or disprove a theory or two, rather than simply adding in more and more 'stuff'.

Note the [Kanban limits to work in progress](http://leanca.mp/2011/12/better-learning-through-velocity-how-to-use-kanban-to-learn-better/). In order to get theories tested as fast as possible, it's important to get them through the process as fast as possible.

*You can view and interact with the board for yourself:* it's [on Trello here](https://trello.com/board/sol-hypotheses/4fb0cbe79c2ff2de54036903). I'm determined to do as much of this learning in the open as possible. I'd love your input into the hypotheses that I'm testing: you can vote and comment on particular theories and tell me why you think they're a true (or completely wrong). Any input you give here will have an effect on what I work on next, so if you want to influence the development, then get involved!

## Freed from featuritis

I've really enjoyed freeing myself from the continual focus on &quot;features features features&quot;. Features by themselves mean nothing: they are actually a drag on your product, as you have to spend time and effort maintaining them. It's only the value that your customers gain from them that's important. Focusing on theories has meant that I'm always making progress, even if I'm simply learning what doesn't work.

## Hang on: where is creativity in all this?

There's a delicate balance here between listening to your customers and leading them in the direction you think they should go. I'm not going to sacrifice design flair and narrative to satisfy the baying (buying?) masses. This will likely always be a little bit of a niche game: there is a limit to the number of people interested in the genre. I plan to ultimately build the game I want to play, as opposed to the selling of something rubbish to satisfy everyone. Where's the fun in that?

The important thing is to learn about your customer base, *within the context of your original vision.* If you cannot build a product within those constraints, time to look for a new business. Luckily, one of the earliest things I learnt through mailing list signups and a couple of [hacker news](/2012/01/why-i-switched-from-ruby-back-to-c-plus-plus/) [appearances](/2012/01/switching-sol-trader-from-ruby-to-c-plus-plus-one-week-on/) is that there's a fair amount of latent demand for the vision I've got for the game, which is what spurred me on to [get the alpha out](/2012/05/sol-trader-now-in-alpha) in the first place.

What do you think of learning in public like this, and what do you think of my development approach?

&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;.
&lt;/div&gt;

</content></entry><entry><title>Sol Trader now in Alpha</title><category term='sol trader'/><category term='products'/><category term='agile'/><category term='lean'/><category term='lean startup'/><link href='http://chrismdp.com/2012/05/sol-trader-now-in-alpha'/><updated>2012-05-02T15:37:44+01:00</updated><id>http://chrismdp.com/2012/05/sol-trader-now-in-alpha</id><content type='html'>## It's released!

After a hectic four months of early development &lt;a href='http://soltrader.net'&gt;Sol Trader has gone into Alpha&lt;/a&gt;.

&lt;a href='http://soltrader.net'&gt;&lt;img src='http://soltrader.net/files/sol-trader-hero.png' style='width: 48em'/&gt;&lt;/a&gt;

With this release, you can explore the known Solar System and make money through trading on the stock markets. There isn't much else there yet, but I'm planning a slew of improvements over the coming months.

I've decided to charge right off the bat: you can buy the Alpha for £5 (about $8). This price will go up as I put more work into the game, and future game updates will be free until it's finished.

## Exciting yet terrifying

This is both a wonderfully exciting and deeply terrifying moment for me. The game isn't near finished, yet I've released it on an unsuspecting set of game players. I've been reading the [Lean Startup](http://theleanstartup.com/) and I think it's ready for feedback. This is my [Minimum Viable Product](http://www.startuplessonslearned.com/2009/08/minimum-viable-product-guide.html).

The exciting bit: I finally get a sense of whether I'm going in the right direction and whether people might enjoy the fairly simple mechanics that are on offer in this version. Seeing Paypal emails letting me know that people have bought the game is very gratifying, even if I have to manually activate every purchase with a knocked-together ruby script.

The terrifying bit is: I finally get a sense of whether people actually might play this game. After all, if nobody likes it at all, there's not much point continuing.

## How I'm going to improve the game

I'm using [KISSMetrics](http://kissmetrics.com) to track both website activity and gameplay. So far it's working out well: I can see how people go through the site, make purchases, and then sign in and play the game.

I've deliberately not worked on the code behind the game for a couple of days, to let the metrics filter through and inform me about what's next.  So far the reaction has been generally positive - my metrics have had good framerates and people are playing for an average of 15 minutes and making about a dozen visits to planets each.

My first impressions based on early metrics and feedback: *I need to make the economy more realistic* as I think this will cause people to play the game for longer, and *I need to add a video of gameplay* to the front page to improve my sign up/purchase rates.

More on how I'm following the Lean Startup approach over the next few weeks and months.

## The long road

This is where I need self-discipline more than ever. My weakness is that when I feel like I've achieved something (like launching an alpha), my tendency is straight away to look for the next thing. I'm determined not to let that happen here. *I feel like I've delivered on perhaps 5% of the vision for the game.* I'm passionate about seeing the rest of the vision fulfilled.

The more of you who buy the game now and play it, the clearer the way forward becomes. I'm grateful for every purchase: thank you to the brave early adopters!

If you've purchased the game, what can I do to improve it? If you haven't purchased it yet, what can I put on the website to better inform your decision? [Let me know](mailto:chris@soltrader.net).

&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;.
&lt;/div&gt;

</content></entry><entry><title>Sol Trader: a continuous deployment story</title><category term='sol trader'/><category term='windows'/><category term='jenkins'/><category term='products'/><link href='http://chrismdp.com/2012/03/sol-trader-continuous-deployment'/><updated>2012-03-23T12:13:27+00:00</updated><id>http://chrismdp.com/2012/03/sol-trader-continuous-deployment</id><content type='html'>&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can now do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;!
&lt;/div&gt;

Continous Deployment is difficult, time consuming to set up and tends to require a high level of buy in from your stakeholders in order to trust the work that you're doing.

It's also one of the best things that could ever happen to your project. It prevents bugs, keeps the whole team on their toes, increases buy in and saves masses of time in the long run.

## Sol Trader on windows

For the last few weeks I've been working hard on getting Sol Trader building and running on Windows. I bought a brand new [low-spec Windows 7 PC](http://www.amazon.co.uk/Zotac-ZBOX-ID41-B-ZBOX-ID41-Mini/dp/B004SLVXYE/ref=sr_1_2?ie=UTF8&amp;qid=1332504948&amp;sr=8-2) for this very purpose, and installed [MinGW](http://www.mingw.org) on it in a blaze of optimism.

Why prioritise Windows? Well, apart from the fact that my artist, Aamar, runs Windows, most of the game playing world out there still seem to be stuck on Windows as a platform, so I decided I had to ensure that it should work earlier rather than later. I figured that the longer I left it, the worse it would be to port over.

Turns out I was *so right*. Getting the game running on Windows was extremely hard and fiddly to do, even after only a few weeks development. I'll post my specific experiences writing a cross-platform Rakefile and dealing with all the path issues another time.

After the game finally ran, my first thought was: &quot;I'm never doing that again.&quot; If I leave the codebase to diverge again, who knows how hard it will be when it's three times the size with twice as many library dependencies.

What I really want to happen is whenever I push new code it's all checked on Windows to make sure that it compiles and runs without warnings or errors, and runs all the tests to ensure that my code never diverges again...

## Jenkins

Enter [Jenkins](http://jenkins-ci.org). Jenkins is the world's most fabulous build system. There are many out there, but I keep returning to Jenkins as the most powerful and flexible. Plus, it's Java, so it easily runs on Windows, so I can simply install it on the same Windows machine for now.

Most importantly for me, it can build using slave computers, so I installed it and set up my Windows machine as a headless slave using Java Web Start. That was thankfully pretty easy to do, once I'd figured out how to set up the build command so it called the right command. It's extremely easy to set Jenkins up to check for the latest pushed code and run a new build for me.

## Packaging

I have a fairly simple rake task which packages up my app in a windows ZIP:

{% highlight ruby %}
task :dist =&gt; [exe] do
  rev = &quot;sol-#{VERSION}-#{fetch('git rev-parse HEAD')[0, 7]}&quot;
  if windows?
    sh &quot;cp /mingw/msys/1.0/local/bin/SDL2.dll .&quot;
    sh &quot;cp /mingw/msys/1.0/local/bin/libfreetype-6.dll .&quot;
    sh &quot;cp /mingw/msys/1.0/local/bin/libRocketCore*.dll .&quot;
    sh &quot;cp /mingw/msys/1.0/local/bin/libRocketControl*.dll .&quot;
    sh &quot;cp /mingw/bin/SDL2_image.dll .&quot;
    sh &quot;cp /mingw/bin/libz-1.dll .&quot;
    sh &quot;cp /mingw/bin/libgcc_s_dw2-1.dll .&quot;
    sh &quot;cp /mingw/bin/libstdc++-6.dll .&quot;
    sh &quot;zip -or #{rev}.zip data shaders media #{exe}.exe *.dll&quot;
    sh &quot;mv #{rev}.zip /c/dropbox/sol/builds/&quot;
  end
end
{% endhighlight %}

This dumps a ZIP file containing all the different DLLs plus the executable and assets into Dropbox for Aamar to pick up. They're helpfully named after the latest commit (the latest one is `sol-0.1-0ead098.zip`) so Aamar and I can refer to them easily.

Now when I push the code, I only have to wait a few minutes and Dropbox informs me of a new build available. Bliss.

![Jenkins running](/files/sol-jenkins-build.png)

## Next steps

* I've an iMac at home which we use as a family PC, but they have SSH, right? There's nothing to stop me utilising that as my slave machine for building OSX builds automatically. Jenkins allows you to build multiple configurations at the same time, so soon there will be an OSX application appearing alongside the Windows ZIP. Just don't tell my son when he's playing Minecraft...
* I'd like to run the game for 100 frames or so just to ensure that it's starting, allocating all its memory and exiting cleanly without memory leaks.
* [Valgrind](http://valgrind.org) support would be fantastic to check for leaks.
* A screenshot showing the running game to double triple check it would be a great addition. There's a Jenkins plugin for this, which I've not tried yet.

This is all important infrastructure getting ready for a beta release. Putting in the effort now makes the job of releasing new builds so much easier when the pressure is on and I'm trying to get bugfixes out to multiple platforms.

What do you think of the system so far? Any improvements I could make?

&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can now do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;!
&lt;/div&gt;
</content></entry><entry><title>Sol Trader: on lighting</title><category term='products'/><category term='c++'/><category term='code'/><category term='opengl'/><category term='sol trader'/><category term='game development'/><category term='lighting'/><link href='http://chrismdp.com/2012/02/sol-trading-lighting'/><updated>2012-02-14T22:56:43+00:00</updated><id>http://chrismdp.com/2012/02/sol-trading-lighting</id><content type='html'>A quick update on the lighting code I've been working on. Now that I have normal maps and per-pixel bump mapping working, I can turn these:

![ship-texture-1](/files/sol-trader-lighting-1.png)
![ship-texture-2](/files/sol-trader-lighting-2.png)

Into this:

![ship-texture-3](/files/sol-trader-lighting-3.png)
![ship-texture-4](/files/sol-trader-lighting-4.png)

Check out how the ship appears lit from each side. It looks even better as you see it moving. Hey presto: a realistic 3D effect with only two triangles rendered.

All I'm using is this simple GLSL fragment shader:

{% highlight c %}

    void main() {
      vec4 color = texture(baseTexture, uv);
      vFragColor = vertColor * color;
      float alpha = vFragColor.a;

      if (alpha &gt; 0.0 &amp;&amp; useNormal) {
        vec3 lightDirection = normalize(vec3(0.2, 0.2, 0.0));
        vec4 normal = normalize(texture(normalTexture, uv) * 2.0 - 1.0);
        vec4 vEyeNormal = normalMatrix * normal;

        float diffuse = max(0.0, dot(vEyeNormal.xyz, lightDirection));
        vFragColor *= (diffuse * 3);
        vFragColor.a = alpha;
      }
    }

{% endhighlight %}

[GLSL](http://en.wikipedia.org/wiki/GLSL) is great.
</content></entry><entry><title>Effective bloom in OpenGL for Sol Trader</title><category term='products'/><category term='c++'/><category term='code'/><category term='opengl'/><category term='bloom'/><category term='sol trader'/><category term='game development'/><link href='http://chrismdp.com/2012/02/effective-bloom-in-open-gl-for-sol-trader'/><updated>2012-02-02T16:28:30+00:00</updated><id>http://chrismdp.com/2012/02/effective-bloom-in-open-gl-for-sol-trader</id><content type='html'>&lt;div class='notice'&gt;
  &lt;h2&gt;TL;DR&lt;/h2&gt;

  &lt;p&gt;Skip to the &lt;a href='#pictures'&gt;pictures&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;

I've been working on and off on [Sol Trader](http://soltrader.net) ([C++ version](/2012/01/why-i-switched-from-ruby-back-to-c-plus-plus/)) for about a month now. At the beginning of this week, I've been coded up an effective type formatting system using freetype2 natively with OpenGL, which is now in and showing even rather esoteric fonts nicely.

The second half of this week was spent adding on a bloom filter to the graphics engine.

## Bloom filtering: making your world stand out

A bloom filter causes bright areas of the image to 'take over' their surrounding area, simulating the high dynamic range of real light. It stops your game world from looking dull and flat and really makes it stand out. See [this article](http://www.gamasutra.com/view/feature/2107/realtime_glow.php) for some nice screenshots from Tron 2.0 - it can also be used for all sorts of glow and blur effects.

So how's it done? The trick is to render your scene to a texture, rather than to the screen. Once you've done that, you blur and downsample that texture a few times, and then display the results combined with the original texture.

Specifically, this is the process my bloom filter follows:

* Render to a texture
* Copy that texture to two more textures, one a quarter of the screen size, and one an eighth of the screen size.
* Blur the two smaller textures using gaussian blur. There are [clever techniques](http://prideout.net/archive/bloom/) which mean you only need six texture lookups to perform a 5x5 gaussian blur. Texture lookups are expensive, so it's worth doing as few as possible.
* Add all these textures together and add an exposure function to cause the white to saturate for strong color values.

Writing the initial bloom filter was fairly easy. Making it fast was *hard:* you have to work at combining the different aspects of the effect to get what you want, with the absolute minimum of effort for your graphics card. My first attempt ran at a paltry 27 frames a seconds, although it looked very nice: I eventually managed to get it to the point where it runs in roughly 150 frames per second and still looks 80% as good.

&lt;div name=&quot;pictures&quot;&gt;
  &lt;h2&gt;What's the result?&lt;/h2&gt;
&lt;/div&gt;

A picture is worth a thousand words, so here are three:

![bloom-1](/files/sol-trader-bloom-1.png)

![bloom-2](/files/sol-trader-bloom-2.png)

![bloom-3](/files/sol-trader-bloom-3.png)

I've deliberately upped the bloom exposure to show off the effect: it is much more obvious when it's moving. Hopefully you can see the volcanic eruptions on Venus are making the outline of the players' ship that much more hazy. The label of the planet also currently has the bloom effect applied: I'll be able to turn that off when I have a more functional GUI in place.

I plan to use this effect for all sorts of things: laser fire, explosions, you name it.

## Next...

I'm going to tackle the gui. I now have AI characters with names trading on Earth's main commodity market: it's time the player joins them in making trades.

&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can now do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;!
&lt;/div&gt;
</content></entry><entry><title>Switching Sol Trader from Ruby to C++: one week on</title><category term='products'/><category term='ruby'/><category term='c++'/><category term='code'/><category term='sol trader'/><category term='game development'/><link href='http://chrismdp.com/2012/01/switching-sol-trader-from-ruby-to-c-plus-plus-one-week-on'/><updated>2012-01-16T09:38:25+00:00</updated><id>http://chrismdp.com/2012/01/switching-sol-trader-from-ruby-to-c-plus-plus-one-week-on</id><content type='html'>Well, I didn't quite expect that. My [previous post](/2012/01/why-i-switched-from-ruby-back-to-c-plus-plus/) about switching [Sol Trader](http://soltrader.net) development from Ruby back to C++ caused [quite a storm](http://news.ycombinator.com/item?id=3440596).

Not being used to making waves on the mainstream Internet, I naively attempted to dive in and read and respond to every comment. It appears that feedback from the Internet at large tends towards the negative, so after a few hours I was feeling pretty discouraged, and only continued replying to some of the constructive feedback. Sorry if you didn't get a response.

I have a few more comparisons between Ruby and C++ which I'd like to share.

* *I'm finding myself reinventing the wheel more.* In Ruby-land I found third-party code easier to read, easier to install and easier to use. Trying to use someone else's library is C++ is harder. Often people don't seem to write automated tests, which strongly recommends me against using them. I'm also concerned that new libraries might introduce hidden memory leaks which will waste me time massively when I come to hunt them down. I appreciate people don't release their code just for me, so I'm not complaining: I've just found it more difficult to trust third-party code. I hope to try and fix this tendency by releasing large extractions from my project as libraries in the future.

* *Boost is awesome.* One notable exception to the above concern is the wonderful [Boost](http://boost.org) library suite. There is a library for almost everything you might need there, and the quality is very high. I'm already using the [Signals2](http://www.boost.org/libs/signals2) library for notifications (following the [Observer pattern](http://en.wikipedia.org/wiki/Observer_pattern)) and I plan to use the [Serialization](http://www.boost.org/libs/serialization) library for saving and loading games.

* *What to test?* The testing profile of my C++ code is different to my Ruby code. Thanks to strong typing, my tests fail for longer during the 'red' stage, so I find I have to write fewer edge cases. There are only so many ways C++ types can fit together, whereas Ruby objects can be combined in any way you like. I'm not sure I've hit on the right level of coverage yet: I'm not writing any tests for the more visual parts of Sol Trader yet and I'd like to consider how to.

* *I'm using a classist approach to testing.* In C++ I've tended to favour a [classical approach to TDD](http://martinfowler.com/articles/mocksArentStubs.html): that of testing a few small classes together from the outside using the public interface. Where I'm [coding to interfaces](http://stackoverflow.com/a/384067/1073735) I'm able to stub out that interface by inheriting from it in my test, but I'm not doing that often. Mostly I'm following my nose and attempting to keep my classes small and my collaborations few. I don't get all the design signals from my tests that I would like, but in my view that's better than exposing the internals of my class to the tests: that just complicates it unnecessarily. C++ is already difficult to read.

* *Prototyping complex class structures in Ruby first is really useful.* I've often benefited from having an existing Ruby class structure to take as my lead when writing C++. Those subsystems that I'd already written in Ruby were at least twice as fast to write. Rather than typing, or getting past the syntax, I've found [learning to be the constraint](http://dannorth.net/2010/08/30/introducing-deliberate-discovery/) in a number of coding situations. I'm not sure I'd always write in Ruby first, but in a case where I was really stuck and wanted to explore possible options, I might consider a rapid Ruby prototype over [CRC card design](http://en.wikipedia.org/wiki/Class-responsibility-collaboration_card), for example.

I'll continue to post my learnings as I collect them.

&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can now do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;!
&lt;/div&gt;
</content></entry><entry><title>Why I switched from Ruby back to C++</title><category term='products'/><category term='ruby'/><category term='c++'/><category term='code'/><category term='sol trader'/><category term='game development'/><link href='http://chrismdp.com/2012/01/why-i-switched-from-ruby-back-to-c-plus-plus'/><updated>2012-01-08T20:21:41+00:00</updated><id>http://chrismdp.com/2012/01/why-i-switched-from-ruby-back-to-c-plus-plus</id><content type='html'>&lt;div class='notice'&gt;
  &lt;b&gt;UPDATE:&lt;/b&gt; This post was pretty popular. I've posted a followup &lt;a href=&quot;/2012/01/switching-sol-trader-from-ruby-to-c-plus-plus-one-week-on/&quot;&gt;here&lt;/a&gt;.
&lt;/div&gt;

After two months of Sol Trader development in Ruby, I took a difficult decision last Wednesday morning: I've decided to rewrite the game code from scratch in C++. Let me explain my reasons.

&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can now do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;!
&lt;/div&gt;

## Why I did it

* *Slow frames:* When working with Ruby, I use the excellent [Gosu](https://github.com/jlnr/gosu) library to do all my game specific coding. This initially worked great, but occasionally I'd just get slow frames coming up. My game is timed to run at 60 frames per second, which means that each frame should take no more than 16.67ms to run. Yet every so often my profiling would come up with a frame that would take 25ms or 45ms for no discernible reason. I just couldn't find the issue here: I turned every sub system in the game off. I disabled garbage collection. I hacked my slow frame detection code into the simplest gosu sample I could find, and they still existed. I didn't feel like I could quite trust the stack to deliver the framerate I needed, and I hadn't yet put in half the features I wanted to.

* *Object explosion when bridging to C:* A lot of the libraries I was using were written in C, and therefore there was several thousand objects (mostly floats) being created each frame to act as a bridge between Ruby and C code. It feels like that that CPU time should be better spent in the AI improving the quality of the simulation, or on better effects, rather than loading the garbage collection with an unnecessary burden.

* *Ease of packaging and distribution:* I feel like packaging is going to be a lot easier. I'm not too bothered about hiding the source code: I may well do that anyway to purchasers of the game. It's the running on Windows I'm worried about: from my research it feels like it's going to take some effort to push the game out on a non-Unix platform. And with a video game, releasing on Windows is a must.

* *Manual memory management for performance:* The garbage collection is still too stuttery under MRI (even with Ruby 1.9.3, which is a huge improvement on what's gone before) - it still stops the world each time. I looked at other implementations, and even considered learning all about garbage collection to help improve Ruby myself, but then realised that getting royally distracted wouldn't help me ship a working game.

## What do I miss about Ruby?

* *I miss using RSpec hugely:* There are ways of doing [testing of C programs using RSpec](http://benmabey.com/2007/09/09/bdd-your-c.html) but it doesn't feel like I want to wrap each of my C++ classes with a SWIG interface just to check they're working. I may still do this for some form of Cucumber testing, I'm not sure. I'm using [UnitTest++](http://unittest-cpp.sourceforge.net/) for my testing at the moment, which is very lightweight and good enough for my purposes.

* *Duck-typing:* defining interfaces for everything is a pain in the backside, although it does force you to think more clearly about the roles of your classes.


* *Easy mockist testing:* There's no built in reflection in C++ so it also makes you have to code to interfaces if you want to do any mockist testing. I'm mostly returning to a classist style of testing with small well defined groups of classes being tested at once. It's not a perfect system and I still have much learning to do here.

* *Terseness of syntax:* There's just a lot more characters to type, and a lot more ceremony for each class. This tempts you to larger classes and methods, which I'm resisting at the moment. I need to take the time to set up [c.vim](http://www.vim.org/scripts/script.php?script_id=213) exactly how I want it.

Funnily enough, I don't miss the automatic memory management: I like having that level of control. Old habits die hard.

## So how far have I got?

Thankfully, it's not a complete rewrite as I'd already done a lot of thinking about the architecture and a lot of the basic classes translate directly over.  I worked really hard at the end of last week and got a lot done:

* I put in [SDL](http://www.libsdl.org) to build the basic game framework: hopefully building on Windows will be a snap. I plan to have a working Windows build as soon as I can lay my hands on a cheap Windows 7 PC.
* Basic testing using UnitTest++, with tests that are compiled and run as part of the build process.
* Decoupled gameplay/physics updates from the graphical framerate using the techniques [here](http://gafferongames.com/game-physics/fix-your-timestep/). I have zero [temporal aliasing](http://en.wikipedia.org/wiki/Temporal_anti-aliasing) bugs right now, which makes for a super smooth 300+ FPS graphic loop with a fixed 60FPS physics loop.
* Re-implemented physics using [Chipmunk](http://chipmunk-physics.net/), the same library I used in Ruby, which made it very easy to switch over.
* Put in a brand new and much improved parallax-scrolled starfield.
* Added a basic controllable spacecraft, planets and jumpgates back in: the player can fly around as before and collide successfully with other objects.
* A simple particle system so the spacecraft give off exhaust smoke, and the jumpgates emit spooky purple mist.

Even with using OpenGL [immediate mode](http://en.wikibooks.org/wiki/OpenGL_Programming/GLStart/Tut3#Immediate_Mode) (this is a bad thing) and rendering 10000 stars each frame (very inefficient), and a throwing bunch of particles onscreen, I'm still getting 300+ FPS on my 2009 MacbookPro and only using 30MB of memory. That's satisfying.

*UPDATE:* By (very) popular demand, here's a screenshot. Be aware this is *three days work only*, and obviously not final artwork:

&lt;a href='/files/sol-trader-1.png'&gt;&lt;img src='/files/sol-trader-1.png' width='500'/&gt;&lt;/a&gt;

Next I plan to add back in jumping between different planetary orbits, and then work on a very basic 'person-level view', so that you can get out of your ship and walk around.

## Was it the right decision?

I'll know at the end of the project :) My feeling is though that it was the correct thing to do. Being really close to the metal will make it much easier to implement some of the really complex AI stuff I'd like to do later on. I already know C++ very well, and estimate it'll only delay me a week or two if I work hard. If I like, I can always bundle my project as a C++ library and control it from Ruby later on, but it's harder to go in the other direction.

What do you think? Did I make the right call?

&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can now do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;!
&lt;/div&gt;
</content></entry><entry><title>Introducing Sol Trader</title><category term='products'/><category term='code'/><category term='life'/><category term='sol trader'/><category term='game development'/><link href='http://chrismdp.com/2012/01/introducing-sol-trader'/><updated>2012-01-03T14:53:53+00:00</updated><id>http://chrismdp.com/2012/01/introducing-sol-trader</id><content type='html'>Happy new year, everybody! It's been a little while in coming, but I've finally got to the point where I want to announce the project I've been working on privately for the last few months. I'm heading after a dream, and I want to share it with you.

But first some background.

## I love designing games

I started my career in software development working on PC games back at the turn of the millennium. I worked for a fantastic little company called [Elixir Studios](http://en.wikipedia.org/wiki/Elixir_Studios), which sadly closed in 2005. I'll never forget them: they gave me my first break into software development and I studied my craft under some fantastic mentors, notably [Achim Stremplat](http://www.linkedin.com/in/achimstremplat) and [Jamie Doornbos](http://www.linkedin.com/profile/view?id=3207719&amp;locale=en_US&amp;trk=tyah). These guys taught me a love of good code, and a love of doing things right.

On leaving Elixir, I moved away from the games industry and into web programming, leaving C++ and Microsoft Visual Studio far behind me. I spent a few years shifting through a number of languages (Perl, PHP, Java, Python) before settling on Ruby as my interpreted language of choice. I've never lost that love for building and designing games, though, and I've kept my hand in over the years. I've always been more interested in designing games, rather than playing them: as a kid I was always the Dungeon Master, or the guy [designing the adventure](http://en.wikipedia.org/wiki/HeroQuest). As an 11 year old I used to write games in BASIC on BBC Micros and sell them to my friends for 10p each. I guess you could say it's built in to my psyche.

## Sol Trader

Another realisation: one of the things that I've learnt in the last year is that I'd love to spend more time working on my own products. I have done this in a half-hearted fashion over the years, but my motivation tends to die off when the initial rush of enthusiasm fades. To help myself see it through to the end, I've decided to try to realise a long held dream. Alongside working with clients this year, I'm going to spend some of my remaining time building and releasing my first commercial game.

I'm therefore very pleased to announce [Sol Trader](http://soltrader.net) - an open-ended space trading and exploration game set in our solar system in the near future.

The game itself has been in development since the end of October last year: it started as a side project with my kids (we originally named it Spacestuff) but has blossomed and grown into something much more. There's some info [on the website](http://soltrader.net) I've been putting together, but more will be forthcoming shortly. I'm aware that I've not got any screenshots yet, but once the first artwork goes in I'll put some up. It's already playable: my kids are already having great fun travelling between Earth and Venus via jump gates and landing on the planets.

When I'm ready for beta testers, I'll put an announcement out on the mailing list: [sign up at soltrader.net](http://soltrader.net).

## Motivate me!

One of the things I need to work on is the ability to complete my own projects. Working on a game is a great motivator, but I need help to keep my motivation up! I'd be very grateful if you'd drop me a note asking me how I'm getting on if you don't hear from me for a while. Write a comment on a blog post, retweet something, sign up to get emails, ping me [on twitter](http://twitter.com/chrismdp): every little bit of feedback I get (even if critical) helps to motivate me to work on it.

More on the game in future posts, including some thoughts on architecture, language choice and whether or how to release the source code. Crafting this codebase has already proved a treasure trove of interesting thoughts on code quality and testing, which I plan to share on this blog over time. I'm also aware that I'm breaking a few &quot;indy game developer&quot; rules: I'll share my opinions about that, too.

Will I finish? Will it be a success? I've no idea, but I plan to learn as much as possible from doing it. At the very least, I'm shooting after a dream, and I'll be pleased to finish 2012 having attempted it, whatever the outcome.

Have you got a [half-baked dream](http://www.youtube.com/watch?v=_Klf8uWkvaw) you're going to turn into reality this year? If not, why not?

</content></entry><entry><title>Kanogo: vapourware to beta in 24 hours</title><category term='code'/><category term='products'/><category term='business'/><category term='kano analysis'/><category term='rails'/><category term='heroku'/><category term='ruby'/><category term='kanogo'/><link href='http://chrismdp.com/2011/09/kanogo-vapourware-to-beta-in-24-hours'/><updated>2011-09-12T11:30:37+01:00</updated><id>http://chrismdp.com/2011/09/kanogo-vapourware-to-beta-in-24-hours</id><content type='html'>&lt;div class='notice'&gt;
  &lt;h2&gt;TL;DR&lt;/h2&gt;

  &lt;p&gt;Last week I built the first beta of a new web product called &lt;a href=&quot;http://kanogo.com&quot;&gt;Kanogo&lt;/a&gt;. It’s designed to gather feedback and perform &lt;a href=&quot;http://en.wikipedia.org/wiki/Kano_model&quot;&gt;Kano analysis&lt;/a&gt; to determine which direction you should take with your website.&lt;/p&gt;

  &lt;p&gt;Here's an example, designed specifically for this blog. Thanks for your feedback!&lt;/p&gt;

  &lt;iframe allowtransparency='true' frameborder='0' scrolling='no' src='http://kanogo.com/surveys/13/embed?' style='width: 100%; height: 120px'&gt;
  &lt;/iframe&gt;

  &lt;p&gt;Sign up for the beta &lt;a href='http://kanogo.com'&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;/div&gt;

## The backstory

A while back I agonising over which should be the next greatest feature for one of my products. I thought the best thing to do would be to conduct some Kano analysis on the product in question, and realised there wasn't an easy way of doing this. I've used [kanosurvey.com](http://kanosurvey.com) in the past, but it didn't really feel like the right tool. How was I to get users to answer my survey?

&quot;Wouldn't it be great,&quot; I thought, &quot;if I could embed a little survey box on the site that asked customers what they thought and provided me with Kano analysis stats?&quot; The concept behind [Kanogo](http://kanogo.com) was born.

Fast forward several months to last week. I found myself with a few days spare and decided that the best use of them would be to build a beta of this product. Always up for a challenge, I decided to give myself 24 hours to build and launch.

That's not very long, so I had to hustle.

## Timeline

*7 Sep: 12:10am:* [I announced my intentions](https://twitter.com/#!/chrismdp/status/111214768651636736), mostly to motivate myself through fear of failing in public. I finally decided on a name, and registered the domain and the twitter account. I announced the product [to the world](https://twitter.com/#!/chrismdp/status/111240345341263872) (well, a [subset](https://twitter.com/#!/chrismdp/followers)).

*7 Sep: 01:55am:* Got a new Rails 3.1 app running on Heroku cedar. It's a one page app using a Campaign Monitor signup form. Got my first beta signup. Finished for the night.

*7 Sep: 07:40am:* Announced Kanogo again, just in case anyone had been sleeping at 2am :) Got another 3 beta signups and a bunch of feedback on spelling errors.

*7 Sep: 10:13am:* Simple twitter sign in done using [Omniauth](https://github.com/intridea/omniauth) and this really useful [tutorial](https://github.com/RailsApps/rails3-mongoid-omniauth/wiki/Tutorial).

*7 Sep: 02:45pm:* The USA woke up and I got more beta signups: now up to 5. Got the basic data entry for surveys and features done. Started work on the embed. Was feeling fairly pessimistic about a beta launch for that night, but didn't want to let myself down.

*7 Sep: 05:53pm:* Embed done, quicker than expected. Took a break. Now feeling [cautiously optimistic](https://twitter.com/#!/chrismdp/status/111482135218626560).

*7 Sep: 09:12pm:* Basic response mechanism in: now needed to apply the Kano analysis magic! Adrenalin took over from caffiene as primary stimulant.

*7 Sep: 11:20pm:* Turned on twitter sign in as basic method of getting registered on the site. Removed redundant Campaign Monitor signup: emailed subscribers manually to ask them to sign in via twitter. Beta [went live!](https://twitter.com/#!/kanogoapp/status/111564545708929024)

## The result

![Embed](/files/kanogo-1.png)

![Results](/files/kanogo-2.png)

After 24 hours, I had a beta running, which worked. Granted, it wasn't great, but it was something that had some value.

I spent the rest of the evening and following morning promoting the beta on mailing lists and on twitter. By the end of the following day I had 30 or so beta signups.

It's already adding value to beta users. Two sites using the beta already on their own products. One beta user has now decied to implement a feature as he's realised his customers consider it a &quot;must have&quot;. There's no substitute for real feedback.

## Learnings

Some of the things I've learned so far:

* *Cloud tools are the business.* It was so easy to register the domain with [dnsimple.com](http://dnsimple.com), start up a [twitter account](http://twitter.com/kanagoapp) for marketing and customer interaction, deploy to [Heroku](http://heroku.com), get initial beta signups with [Campaign Monitor](http://campaignmonitor.com).

* *Modern development tools rock.* I used Rails 3.1 for this app, which worked beautifully, and I love the use of sprockets to help manage the asset pipeline. Running the app on Heroku cedar went without a hitch. I used twitter for authentication, and it only took an hour to set up.

* *There is no &quot;quick and dirty&quot;.* The app is (almost) fully tested: I confess I left a couple of methods only covered by end-to-end tests (which doesn't really count). I definitely proved that the only way to go fast is to go clean: [Jason was right](http://agileage.blogspot.com/2011/07/slow-and-dirty-rant-by-jason-gorman-at.html) that there is no &quot;quick and dirty&quot; only &quot;slow and dirty&quot;. This came back to bite me instantly: the code I didn't use specs for took me the longest to get working.

* *Technology is the easy part.* It didn't take me long to build the site, but the trick is to build a business. After initial interest, the analytics on the site are way down as the next new thing appears on the internet and people move on. To gain traction I need to build the app my beta users actually want. Thankfully, quick feedback is what Kanogo does, so we're eating our own dogfood and asking our users what they think at every turn. This is already directing which features I work on next, which has to be the most efficient way of moving forward, right?

## What's next?

I plan to continue working on this, listening to beta user feedback, refining the features, and accepting new beta signup for the moment. I hope to turn this into a paid product at some point, as I think there's a huge amount of value here to websites if I can get the messaging right.

## Can I get involved?

Sure! It's not too late to join the beta: you can [do so here](http://kanogo.com). I'd love your feedback on the product. It can give you value anywhere you have users of a website, even on a blog as shown above.
</content></entry><entry><title>Pin in the map: customisable pin icons</title><category term='code'/><category term='cucumber'/><category term='ruby'/><category term='legacy'/><category term='products'/><category term='pininthemap'/><link href='http://chrismdp.com/2011/09/pininthemap-customisable-pin-icons'/><updated>2011-09-06T21:18:13+01:00</updated><id>http://chrismdp.com/2011/09/pininthemap-customisable-pin-icons</id><content type='html'>I've just spent some time updating my first ever Rails project, [Pin in the map](http://pininthemap.com). Now you can change the icons associated with premium (paid for) pins. There are over 100 new icons to choose from: [have fun!](http://pininthemap.com)

![pininthemap example](/files/pininthemap-example.png)

## Learnings

This codebase is from 2006, so this has proved a nice little exercise in adding testing to a legacy project. I had no tests at all to speak of when I wrote the code five years ago, and the code shows it. I began by installing cucumber and rspec and quickly wrapping the two most common features in acceptance tests: creating and editing pins. Even on old code it was super easy to get capybara, cucumber and rspec up and running, thanks to the fact that we've upgraded the codebase to Rails 2 and started using bundler to manage gem dependencies. We stuck to Selenium for the tests as the code is very Google Maps heavy.

It's always worth keeping old apps vaguely up to date: the less inertia surrounding a codebase the more likely you'll spend an afternoon adding an often-requested feature.
</content></entry></feed>
