---
layout: nil
---
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Chris Parsons: posts tagged spring</title>

  <link href="http://chrismdp.com/"/>
  <updated>2006-04-11T16:25:00+01:00</updated>
  <id>http://chrismdp.com/tag/spring</id>
  <author>
    <name>Chris Parsons</name>
    <email>chrismdp@gmail.com</email>
  </author>
<entry><title>Spring Richclient ~ That's a wrap</title><category term='richclient'/><category term='java'/><category term='spring'/><category term='tutorial'/><link href='http://chrismdp.com/2006/04/spring-rc-thats-a-wrap'/><updated>2006-04-11T16:25:00+01:00</updated><id>http://chrismdp.com/2006/04/spring-rc-thats-a-wrap</id><content type='html'>&lt;div class='notice'&gt;&lt;h1&gt;By the way...&lt;/h1&gt;&lt;p&gt;This content is now pretty old: check &lt;a href='/'&gt;the homepage&lt;/a&gt; for the latest.&lt;/p&gt;&lt;/div&gt;
          
&lt;p&gt;My project is shrink-wrapped in virtual plastic and the client is happy, so that just about wraps up my look at Spring Rich Client. &lt;/p&gt;
&lt;p&gt;After writing a full app from conception to completion, I thought that it was a useful and powerful framework deserving of attention. There are plenty of features you get thrown in for free, such as decent localisation support and excellent form binding capabilities. A couple of closing thoughts follow...&lt;/p&gt;
&lt;p&gt;The framework needs more documentation. Once you master the basics you're ok, but I get the nagging feeling I missed whole sets of features simply because I didn't know they were there.&lt;/p&gt;
&lt;p&gt;A maintained stable release would be a significant step forward. Once the project was easier to download and try out I think many more people would at least evaluate it. The more people using it, the more developers that might come forward, which has to be a good thing for the project.&lt;/p&gt;
&lt;p&gt;I hope you enjoyed our little jaunt. Best of luck on your own Spring Rich Client journey.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Update:&lt;/b&gt; It looks like Spring: Rich Client have released 0.1.0 on sourceforge; the first stable revision! Should have checked before I wrote this post :) Congratulations to the Rich Client team - hopefully the project will move forward in leaps and bounds now.&lt;/p&gt;
</content></entry><entry><title>Spring Richclient ~ A Journey</title><category term='richclient'/><category term='java'/><category term='spring'/><category term='tutorial'/><link href='http://chrismdp.com/2006/04/spring-richclient'/><updated>2006-04-01T13:00:00+01:00</updated><id>http://chrismdp.com/2006/04/spring-richclient</id><content type='html'>&lt;div class='notice'&gt;&lt;h1&gt;By the way...&lt;/h1&gt;&lt;p&gt;This content is now pretty old: check &lt;a href='/'&gt;the homepage&lt;/a&gt; for the latest.&lt;/p&gt;&lt;/div&gt;
          
&lt;p&gt;This series of articles documented my journey through the depths of Spring Rich Client in an attempt to learn how it all works.&lt;/p&gt;
    
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2006/01/spring-rc-introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2006/01/spring-rc-session-one&quot;&gt;Session One: Making Petclinic work&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2006/01/spring-rc-session-two&quot;&gt;Session Two: Hello, World!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2006/01/spring-rc-session-three&quot;&gt;Session Three: How did that work then?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2006/01/spring-rc-session-four&quot;&gt;Session Four: Beans, shmeans and services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2006/02/spring-rc-session-five&quot;&gt;Session Five: Applications, windows, views&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2006/02/spring-rc-session-six&quot;&gt;Session Six: The View&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2006/03/spring-rc-session-seven&quot;&gt;Session Seven: Beating the Command Framework into Submission&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2006/03/spring-rc-session-eight&quot;&gt;Session Eight: Such a Bind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2006/04/spring-rc-thats-a-wrap&quot;&gt;That's a wrap: Closing Thoughts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><title>Spring Richclient ~ Session Eight ~ Such a bind</title><category term='richclient'/><category term='java'/><category term='spring'/><category term='tutorial'/><link href='http://chrismdp.com/2006/03/spring-rc-session-eight'/><updated>2006-03-09T09:46:00+00:00</updated><id>http://chrismdp.com/2006/03/spring-rc-session-eight</id><content type='html'>&lt;div class='notice'&gt;&lt;h1&gt;By the way...&lt;/h1&gt;&lt;p&gt;This content is now pretty old: check &lt;a href='/'&gt;the homepage&lt;/a&gt; for the latest.&lt;/p&gt;&lt;/div&gt;
          
&lt;p&gt;Let's look at the binding framework today. I've got an options dialog to write, and it looks like the binding framework could be just the ticket...&lt;/p&gt;
&lt;p&gt;For the uninitiated, when we talk about &quot;binding&quot; we mean linking values in a text field on a form to values in our Java class. Essentially we want to turn:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
  public class TrafficWarden {
    String name = &quot;Trevor the Traffic Warden&quot;;
    String parkingTicketCount = 124023;
  }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;into this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/files/rcp-8-0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;And when the user hits &quot;Save&quot;, we want the values in our java object to change.&lt;/p&gt;
&lt;p&gt;This is a standard well-defined problem for which there exists a number of solutions. So what does Spring Rich Client give us to aid us in our quest? Let's have a look.&lt;/p&gt;
&lt;h2&gt;How do we make a form?&lt;/h2&gt;
&lt;p&gt;The first example that comes to mind of a view with fields on it is the &quot;owner properties view&quot; in the petclinic sample. This is shown when we right click an owner:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/files/rcp-8-1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Let's have a look at the code which created this page, from OwnerManagerView.java:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
  public void execute() {
    final Owner owner = getSelectedOwner();
    ownerFormModel = FormModelHelper.createCompoundFormModel(owner);
    ownerGeneralForm = new OwnerGeneralForm(FormModelHelper.createChildPageFormModel(ownerFormModel, null));&lt;/p&gt;
&lt;p&gt;    compositePage = new TabbedDialogPage(&quot;ownerProperties&quot;);
    compositePage.addForm(ownerGeneralForm);
    compositePage.addForm(new OwnerAddressForm(FormModelHelper.createChildPageFormModel(ownerFormModel, null)));&lt;/p&gt;
&lt;p&gt;    TitledPageApplicationDialog dialog = new TitledPageApplicationDialog(compositePage, getWindowControl()) {
      protected void onAboutToShow() {
        ownerGeneralForm.requestFocusInWindow();
        setEnabled(compositePage.isPageComplete());
      }&lt;/p&gt;
&lt;p&gt;      protected boolean onFinish() {
        ownerFormModel.commit();
        clinic.storeOwner(owner);
        ownersTreeModel.nodeChanged(getSelectedOwnerNode());
        return true;
      }
    };
    dialog.showDialog();
  }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Ok, to create a form, we do the following things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Grab the currently selected Owner.&lt;/li&gt;
&lt;li&gt;Create a form model for this Owner. So what's one of those? Turns out that the class has got some documentation - from FormModel.java:
{% highlight text %}
      A form model represents the state and behavior of a form independently from
      the UI used to present the form.
{% endhighlight %}
    Ok, so it's an abstract representation of a form. Fine.&lt;/li&gt;
&lt;li&gt;Create an OwnerGeneralForm, passing a &quot;child page&quot; version of the form model. This makes sense - we've got two tabs, one for &quot;General Info&quot; one for &quot;Address&quot;. Rich Client seems to links the &quot;child page&quot; FormModel it creates with the main wizard's FormModel.&lt;/li&gt;
&lt;li&gt;Do a similar thing for the OwnerAddressForm.&lt;/li&gt;
&lt;li&gt;Add both of these forms to a TabbedDialogPage, which I guess does the fancy tab stuff.&lt;/li&gt;
&lt;li&gt;Create a new TitledPageApplicationDialog which takes the TabbedDialogPage we created earlier. We override this dialog to provide stuff to do when it closes.&lt;/li&gt;
&lt;li&gt;Show the dialog!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When we're done with a form, we do the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&quot;Commit&quot; the form; I guess this allows it to reconstruct our data from the form fields.&lt;/li&gt;
&lt;li&gt;Store the updated owner in the clinic.&lt;/li&gt;
&lt;li&gt;Signal to the main view that we might have changed something.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ok, so we've seen how to create a new form, and how to extract the data. Let's try one of our own, and see how far we get.&lt;/p&gt;
&lt;h2&gt;Having a go at an options dialog&lt;/h2&gt;
&lt;p&gt;Ok, first things first - create an options command in commands-context.xml and add it to the edit menu. I was going for the tools menu, but I don't need one for this app, so I'll just call the menu option 'Preferences' and be all 'mac-like' :)&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
&lt;bean id=&quot;optionsCommand&quot; class=&quot;uk.co.myco.myproj.command.OptionsCommand&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;optionsDao&quot;&gt;&lt;ref bean=&quot;myDao&quot;/&gt;&lt;/property&gt;
&lt;/bean&gt;
...
&lt;bean id=&quot;editMenu&quot; class=&quot;org.springframework.richclient.command.CommandGroupFactoryBean&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;members&quot;&gt;
&lt;list&gt;
      &lt;value&gt;selectAllCommand&lt;/value&gt;
      &lt;value&gt;separator&lt;/value&gt;
      &lt;ref bean=&quot;optionsCommand&quot;/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;I need a data access object (DAO) wired into the &quot;OptionsCommand&quot;, as the command has got to load and save the options from somewhere...&lt;/p&gt;
&lt;p&gt;Ok, so we create a new command class in OptionsCommand.java and come to writing doExecuteCommand() (see &lt;a href=&quot;/node/17&quot;&gt;session seven&lt;/a&gt; for details on writing commands). First we need the existing options, and then we need to create a FormModel based on these options, as explained above:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
final Options opt = optionsDao.getOptions();
optionsForm = new OptionsForm(FormModelHelper.createFormModel(opt));
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;As we're not splitting up the options onto different pages (there are only three for this application!) we don't need any of that compound form model stuff. A simple call to FormModelHelper.createFormModel() is all we need.&lt;/p&gt;
&lt;p&gt;We'll come to writing OptionsForm in a minute.&lt;/p&gt;
&lt;p&gt;After that, we need a new dialog:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
TitledPageApplicationDialog dialog = new TitledPageApplicationDialog(new FormBackedDialogPage(optionsForm), null) {
  protected boolean onFinish() {
    optionsForm.commit();
    optionsDao.storeOptions(opt);
    return true;
  }
};
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;This seems straightforward. We create a new TitledPageApplicationDialog, with a FormBackedDialogPage (and therefore our optionsForm) controlling the contents. We override the onFinish() method to 'commit' the form and save the options in the DAO.&lt;/p&gt;
&lt;p&gt;Then we show it:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
dialog.showDialog();
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;...and that's it for OptionsCommand! Easy, huh?&lt;/p&gt;
&lt;p&gt;Hang on, you're probably thinking: what about supplying the text to go into this dialog? This is all controlled by the FormModel we supplied, our own OptionsForm. Let's take a look at how that is implemented:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
public class OptionsForm extends AbstractForm
{
  public OptionsForm(FormModel model)
  {
    super(model, &quot;optionsForm&quot;);
  }&lt;/p&gt;
&lt;p&gt;  protected JComponent createFormControl()
  {
    TableFormBuilder builder = new TableFormBuilder(getBindingFactory());
    builder.add(&quot;url&quot;);
    builder.row();
    builder.add(&quot;user&quot;);
    builder.row();
    builder.add(&quot;password&quot;);
    return builder.getForm();
  }
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;I've shown the whole class, simply to show how short it is. The createFormControl starts up a new builder, adds a &quot;url&quot; field, a &quot;user&quot; field and a &quot;password&quot; field and then spits out a JComponent (the basic Swing GUI object, for the uninitiated). There's not much to creating these FormModels, is there?&lt;/p&gt;
&lt;p&gt;Note that a lot of what I've done here is based on convention. The names of the rows given to the form builder are expected to exist as JavaBean properties in the object you pass to the model. For example, when I do this in OptionsCommand:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
final Options opt = optionsDao.getOptions();
optionsForm = new OptionsForm(FormModelHelper.createFormModel(opt));
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;...the Options object &lt;i&gt;must&lt;/i&gt; contain getUrl()/setUrl(), getUser()/setUser(), and getPassword()/setPassword() methods for this to work. I'm a big fan of convention over configuration, it saves a lot of hassle.&lt;/p&gt;
&lt;p&gt;How to we get those aforementioned messages to work? In the constructor show above, you pass a string detailing what you want the form to be called (mine is called &quot;optionsForm&quot;, although it could easily be called &quot;allyourbasebelongtous&quot; if desired). Then, you simply add message keys to messages.properties based on that key:&lt;/p&gt;
&lt;p&gt;{% highlight text %}
optionsForm.title=Options
optionsForm.description=Change options &lt;b&gt;Note:&lt;/b&gt; Clicking on 'OK' will save the options.&lt;br /&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Note that you can use basic HTML for formatting. Lovely.&lt;/p&gt;
&lt;p&gt;The actual field names are controlled by further message keys in messages.properties, the names of which are simply the names of the JavaBean properties of our Options class:&lt;/p&gt;
&lt;p&gt;{% highlight text %}
url.label=The U&amp;amp;rl
user.label=&amp;amp;Username
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;(Password already seems to have an internal Spring Rich Client label set up, so I didn't bother adding it)&lt;/p&gt;
&lt;p&gt;And... we're done. We're done? Surely not!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/files/rcp-8-2.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;No, we really are done. That wasn't at all hard, was it? When I first implemented this, after I got it compiling, it actually worked first time, too, which shows how little code I needed to write to make it work; if there was any more than a tiny amount of code to write, I would have made a mistake :)&lt;/p&gt;
&lt;p&gt;Regular Swing types are probably thinking: &quot;That's &lt;i&gt;it&lt;/i&gt;? There must be some catch!&quot; No, that really is all the coding you have to do to get a bound form up and running in Spring Rich Client; and there's not a GridBagLayout in sight. This framework is rather good, isn't it? :)&lt;/p&gt;
&lt;p&gt;Next time, we'll probably look the validation framework to ensure the user actually types in valid values...&lt;/p&gt;
</content></entry><entry><title>Spring Richclient ~ Session Seven ~ Beating the Command Framework into Submission</title><category term='richclient'/><category term='java'/><category term='spring'/><category term='tutorial'/><link href='http://chrismdp.com/2006/03/spring-rc-session-seven'/><updated>2006-03-02T17:12:00+00:00</updated><id>http://chrismdp.com/2006/03/spring-rc-session-seven</id><content type='html'>&lt;div class='notice'&gt;&lt;h1&gt;By the way...&lt;/h1&gt;&lt;p&gt;This content is now pretty old: check &lt;a href='/'&gt;the homepage&lt;/a&gt; for the latest.&lt;/p&gt;&lt;/div&gt;
          
&lt;p&gt;There's been a bit of a gap between the last session and this one; mostly because I've been actually doing coding rather than just writing about coding. It's always worth actually doing a bit of coding once in a while; it's quite fun really, and as I also happen to like eating most days (as does my family), some real work is necessary from time to time...&lt;/p&gt;
&lt;p&gt;Anyhow, I apologise for the delay. On with our journey.&lt;/p&gt;
&lt;p&gt;We left off last time looking at the ownerManagerView, and seeing how that was put together. I promised at the end or that session to look at the command framework next, and try and work it out. So here goes.&lt;/p&gt;
&lt;h2&gt;&quot;Scalpal, please&quot;&lt;/h2&gt;
&lt;p&gt;Let's dissect the OwnerManagerView command code into its component pieces and see what it's made of. It looks like the OwnerManagerView creates a bunch of &quot;command executors&quot;, which define what actually happens when a command is executed by the user. There's a lot of different executors in the OwnerManagerView class. Rather than trying to understand them all at once and fry my brain, I think that the best thing to do would be to head through a custom command called &quot;new owner&quot;, and try to understand how it's created and what it does.&lt;/p&gt;
&lt;h3&gt;How does &quot;new owner&quot; work?&lt;/h3&gt;
&lt;p&gt;Right, time to find the new owner command. It turns out that it's defined in commands-context.xml. This useful little file maps various different command locations (menus, toolbars, that sort of thing) to actual commands that do stuff. Let's look for the new owner command - it's in there:&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
  &lt;bean id=&quot;newOwnerCommand&quot;
    class=&quot;org.springframework.richclient.command.TargetableActionCommand&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;commandExecutor&quot;&gt;
      &lt;ref bean=&quot;newOwnerWizard&quot;/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;It's referenced by the &quot;new menu&quot;, which is turn is referenced from the toolbar and the file menu. Neat.&lt;/p&gt;
&lt;p&gt;So what does the command actually do? It runs the executor &quot;newOwnerWizard&quot;. This bean is defined rather simply in the richclient-application-context.xml file:&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
  &lt;bean id=&quot;newOwnerWizard&quot;
	class=&quot;org.springframework.richclient.samples.petclinic.ui.NewOwnerWizard&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;clinic&quot;&gt;
      &lt;ref bean=&quot;clinic&quot;/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Ok, so when you click on &quot;new owner&quot; you get a wizard up (this manifests as a little boxes with some blank fields to fill in). You enter a bunch of information, and when this is finished, this bangs an event over to the main owner view using spring's built-in ApplicationEvent stuff:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
 protected boolean onFinish() {
   Owner newOwner = (Owner)getNewOwner();
   clinic.storeOwner(newOwner);
   getApplicationContext().publishEvent(
     new LifecycleApplicationEvent(LifecycleApplicationEvent.CREATED, newOwner));
   return true;
 }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;(code taken from NewOwnerWizard.java)&lt;/p&gt;
&lt;p&gt;The owner view handles this message, tweaks the tree and redraws based on the new owner:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
public void onApplicationEvent(ApplicationEvent e) {
  if (e instanceof LifecycleApplicationEvent) {
    LifecycleApplicationEvent le = (LifecycleApplicationEvent)e;
    if (le.getEventType() == LifecycleApplicationEvent.CREATED &amp;amp;&amp; le.objectIs(Owner.class)) {
      if (ownersTree != null) {
        DefaultMutableTreeNode root = (DefaultMutableTreeNode)ownersTreeModel.getRoot();
        root.add(new DefaultMutableTreeNode(le.getObject()));
        ownersTreeModel.nodeStructureChanged(root);
      }
    }
  }
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;(code from OwnerManagerView.java)&lt;/p&gt;
&lt;p&gt;Ok, I followed that (I think). Let's try and do a similar thing for the application I'm writing.&lt;/p&gt;
&lt;h2&gt;The File List View&lt;/h2&gt;
&lt;p&gt;I have a main pane which shows a list of files in a directory, called FileListView. I want to have a button which when clicked opens a JFileChooser and returns a directory. This then refreshes my view. Easy enough, you might be thinking. It turned out to be rather tricky unfortunately...&lt;/p&gt;
&lt;h3&gt;Approach One - fire an event to the application context&lt;/h3&gt;
&lt;p&gt;Ok, so I thought I'd set up my command like this:&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
  &lt;bean id=&quot;openFolderCommand&quot;
        class=&quot;uk.co.mintcontent.uploader.command.OpenFolderCommand&quot;/&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;This is a tiny bit of java classage that handles the file dialog (OpenFolderCommand.java):&lt;/p&gt;
&lt;p&gt;{% highlight java %}
public void doExecuteCommand()
{
  final JFileChooser fc = new JFileChooser();
  fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
  int returnVal = fc.showOpenDialog(null);
  if(returnVal == JFileChooser.APPROVE_OPTION) {
    applicationContext.publishEvent(new FolderSelectedApplicationEvent(fc.getSelectedFile()));
  }
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;FolderSelectedApplicationEvent is my own application event to tell us that a new folder is selected.&lt;/p&gt;
&lt;p&gt;Ok, so in FileListView, I need this:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
public void onApplicationEvent(ApplicationEvent e)
{
  if (e instanceof FolderSelectedApplicationEvent)
  {
    FolderSelectedApplicationEvent fs = (FolderSelectedApplicationEvent)e;
    directory = fs.getDirectory();
    drawFileList();
  }
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Done... right?&lt;/p&gt;
&lt;p&gt;Wrong, unfortunately. The problem is that event fires in the application context defined by commands-context.xml, not the main application context defined by richclient-application-context.xml, so I can't talk to the window. What do I do? I do what all experienced and knowledgable techs do: panic and turn to google for help...&lt;/p&gt;
&lt;h3&gt;Approach Two - Move command to main application context&lt;/h3&gt;
&lt;p&gt;Luckily someone aeons ago (well, 2004) &lt;a href=&quot;http://forum.springframework.org/archive/index.php/t-11599.html&quot;&gt;had the same problem&lt;/a&gt; and was smart enough to post to the Spring forums about it. The law of &lt;a href=&quot;#&quot; title=&quot;When All Else Fails, Boot Up Google&quot; style=&quot;border-bottom:1px dotted&quot;&gt;WAEFBUG&lt;/a&gt; is proved right again!&lt;/p&gt;
&lt;p&gt;Ok, so based on that thread, I now know that A) this stuff should be clearer, and B) I can try moving my command to the main application context. This I do, but now it doesn't show the icons on the toolbar button correctly :( Rather than try and work out why that's the case, let's try another approach...&lt;/p&gt;
&lt;h3&gt;Approach Three - TargetableActionCommand&lt;/h3&gt;
&lt;p&gt;Let's do what petclinic appears to do and use a TargetableActionCommand. &lt;a href=&quot;http://www.ditchnet.org/wp/2005/06/05/remedial-spring-rcp-episode-2-targetableactioncommands-and-the-edt/&quot;&gt;This blog post&lt;/a&gt; helped me out setting one of these up.&lt;/p&gt;
&lt;p&gt;So here's the latest definition of the command:&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
  &lt;bean id=&quot;openFolderCommand&quot;
	class=&quot;org.springframework.richclient.command.TargetableActionCommand&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;commandExecutor&quot;&gt;
      &lt;ref bean=&quot;fileListView&quot;/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;This unfortunately didn't work. I can't wire into the fileListView as it's wrapped up inside a view descriptor object:&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
  &lt;bean id=&quot;fileListView&quot;
        class=&quot;org.springframework.richclient.application.support.DefaultViewDescriptor&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;viewClass&quot;&gt;
    &lt;value&gt;uk.co.mintcontent.uploader.ui.FileListView&lt;/value&gt;
  &lt;/property&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;I don't want to write some sort of proxy object to handle this in the main application context either - that seems overkill.&lt;/p&gt;
&lt;h3&gt;Approach Four - Cheat (sort of)&lt;/h3&gt;
&lt;p&gt;Aha - what about this?&lt;/p&gt;
&lt;p&gt;{% highlight java %}
  applicationContext.getParent().publishEvent(
    new FolderSelectedApplicationEvent(fc.getSelectedFile()));
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Let's just use the method described in &quot;Approach One&quot;, except we'll fire the event at the parent context of the current application context, which just happens to be the main context. This might be cheating, but it works, and I've got a deadline looming.&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Whew! Got there in the end. Here's a summary of the way I did this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Define a new command bean &quot;openFolderCommand&quot; in the command context.&lt;/li&gt;
&lt;li&gt;Code OpenFolderCommand, extending ActionCommand, and implementing the ApplicationContextAware interface to get the application context. Code it so that it opens the JFileChooser and fires a FolderSelectedApplicationEvent event at the &lt;b&gt;parent&lt;/b&gt; context of its own context.&lt;/li&gt;
&lt;li&gt;Code the FolderSelectedApplicationEvent, which takes a File so we know which directory we picked.&lt;/li&gt;
&lt;li&gt;Handle the event in FileListView.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I'm sure there's a better and more Richclient-ish way to do much of this. If you know of one, please let me know!&lt;/p&gt;
&lt;p&gt;Next session, I'll probably be looking at either the Master/Detail stuff, or perhaps getting my app onto Java Web Start successfully.&lt;/p&gt;
</content></entry><entry><title>Spring Richclient ~ Session Six ~ The View</title><category term='richclient'/><category term='java'/><category term='spring'/><category term='tutorial'/><link href='http://chrismdp.com/2006/02/spring-rc-session-six'/><updated>2006-02-10T10:07:00+00:00</updated><id>http://chrismdp.com/2006/02/spring-rc-session-six</id><content type='html'>&lt;div class='notice'&gt;&lt;h1&gt;By the way...&lt;/h1&gt;&lt;p&gt;This content is now pretty old: check &lt;a href='/'&gt;the homepage&lt;/a&gt; for the latest.&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;In this session we will look at the ownerManagerView and its associated descriptor. This is the bit which displays the tree view on the &quot;Owner Manager&quot; screen of the Petclinic sample application. Looks like the author got the bean name right :) (What's the hardest problem in computer science? It's naming a class well, so that the next coder can understand what the class does. Believe it).&lt;/p&gt;
&lt;p&gt;Ok, let's have a look at the view descriptor and see how one of those is defined.&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
&lt;bean id=&quot;ownerManagerView&quot;
	class=&quot;org.springframework.richclient.application.support.DefaultViewDescriptor&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;viewClass&quot;&gt;
		&lt;value&gt;org.springframework.richclient.samples.petclinic.ui.OwnerManagerView&lt;/value&gt;
	&lt;/property&gt;
&lt;property name=&quot;viewProperties&quot;&gt;
		&lt;map&gt;
			&lt;entry key=&quot;clinic&quot;&gt;
				&lt;ref bean=&quot;clinic&quot;/&gt;
			&lt;/entry&gt;
		&lt;/map&gt;
	&lt;/property&gt;
&lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;This is fairly straightforward - a descriptor has a class name to instantiate, and what looks like a list of properties to apply to that class on creation. &lt;/p&gt;
&lt;p&gt;The view is created by the descriptor, using the createView() method. This, amongst other things, adds the view to the 'ApplicationEventMulticaster' (defined in richclient-application-context.xml) if the view of type ApplicationListener. I guess this is so the view can get messages from the outside world if necessary. So far, so good.&lt;/p&gt;
&lt;p&gt;So what does this view look like: The main window looks like this, with the ownerManagerView defined in the centre:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/files/rcp-6-1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;Let's see how we define each segment of this view.&lt;/p&gt;
&lt;h3&gt;View Caption&lt;/h3&gt;
&lt;p&gt;AbstractView contains a bunch of accessor methods (that's a fancy word for a 'get' method, in case you weren't aware) to define things like caption, description, display name etc. These are mostly got from the descriptor class. In this case, our descriptor doesn't appear to define them - perhaps it uses defaults. Let's skip a few steps and cheat: We'll search for the caption text and see what we come up with.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;messages.properties: ownerManagerView.label=&amp;amp;Owner Manager&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Aha. Our old friend messages.properties. Let's see what happens if we change this.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;messages.properties: ownerManagerView.label=&amp;amp;Chris' Owner Manager&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Sure enough:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/files/rcp-6-2.jpg&quot;&gt; &lt;img src=&quot;/files/rcp-6-3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;Looks like to define a caption name, it looks like you define the &quot;&amp;lt;viewName&amp;gt;.label&quot; message. And even better, you can define the name in one place and it's changed across the whole application, including in the menus. Neat.&lt;/p&gt;
&lt;p&gt;I'm guessing the icon and other text options are defined in the same way.&lt;/p&gt;
&lt;h3&gt;Laying out the view&lt;/h3&gt;
&lt;p&gt;The OwnerManagerView derives from AbstractView. Poking through AbstractView, we find the following:&lt;/p&gt;
&lt;p&gt;{% highlight java %}protected abstract JComponent createControl();{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Ok, so that looks like the method that's called when the view needs to be created. How does OwnerManagerView define this?&lt;/p&gt;
&lt;p&gt;{% highlight java %}
protected JComponent createControl() {
   JPanel view = new JPanel(new BorderLayout());
        createOwnerManagerTree();
        JScrollPane sp = new JScrollPane(ownersTree);
        view.add(sp, BorderLayout.CENTER);
        return view;
    }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Ok, we're in standard Java Swing territory here. First we create a shiny new panel, with a simple layout. We create the owner manager tree, a new scroll pane to hold it, and then add the scroll pane to the panel.&lt;/p&gt;
&lt;h3&gt;The Tree&lt;/h3&gt;
&lt;p&gt;The createOwnerManagerTree() method is fairly straightforward Java Swing component construction also, except that there are a number of utility classes and interfaces built into Spring Rich Client which help you out. The FocusableTreeCellRenderer class, for example, makes the tree cells work a little more like windows trees (therefore, how people expect them to work, for better or worse). Choosing what to display in each tree cell is standard Swing API legwork, except that Spring Rich Client makes it easy to pick an icon - see this snippet from the custom treeCellRenderer:&lt;/p&gt;
&lt;p&gt;{% highlight java %}this.setIcon(getIconSource().getIcon(&quot;owner.bullet&quot;));{% endhighlight %}&lt;/p&gt;
&lt;p&gt;That refers to our plumbed in icon source bean, which we looked at in &lt;a href=&quot;/node/11&quot;&gt;Session Four&lt;/a&gt;. Let's be mischievous and change this icon to the spring logo, and see what happens:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;owner.bullet=spring-logo.gif&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This is what we get:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/files/rcp-6-4.jpg&quot;&gt; &lt;/p&gt;
&lt;p&gt;Hmm - that doesn't look like the spring logo... But hang on, what's that on standard output?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WARNING: Unable to load image resource at 'class path resource [images/spring-logo.gif]';
returning the broken image indicator.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Oops. Looks like I typed the name incorrectly. Let's try:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;owner.bullet=spring-logo.png&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/files/rcp-6-5.jpg&quot;&gt; &lt;/p&gt;
&lt;p&gt;That's better. It's looks awful, but that's what you get for sticking so large an image on a tree cell. I'm surprised it worked at all, actually :)&lt;/p&gt;
&lt;h3&gt;Tree Events&lt;/h3&gt;
&lt;p&gt;How do we handle events generated by this tree? Check out this cool Spring Rich Client utility class, TreeStatusBarUpdater:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
  ownersTree.addTreeSelectionListener(new TreeStatusBarUpdater(getStatusBar()) {
    public String getSelectedObjectName() {
      Owner selectedOwner = getSelectedOwner();
      if (selectedOwner != null) {
        return selectedOwner.getFirstName() + &quot; &quot; + selectedOwner.getLastName();
      }
      else {
        return &quot;Owners&quot;;
      }
    }
  });
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;When we select a new node, this inline class allows us to easily supply a String to update the status bar with. That's really neat.&lt;/p&gt;
&lt;p&gt;Similar utilities exist for the mouse listeners:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
  ownersTree.addMouseListener(new PopupMenuMouseListener() {
    protected boolean onAboutToShow(MouseEvent e) {
      return !isRootOrNothingSelected();
    }&lt;/p&gt;
&lt;p&gt;    protected JPopupMenu getPopupMenu() {
      return getSelectedOwner() != null ? createOwnerPopupContextMenu() : createPetPopupContextMenu();
    }
  });
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;All you do is define whether or not to show the popup, and which menu to show if you do. Creating Java's Swing components in Spring Rich Client seems to be a breeze...&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;This session, we learned how to create and lay out views in Spring Rich Client. We looked at the view descriptor and how it uses default labels to display captions and icons. We saw how easy it is to create tree components that feel 'right', and we oohed at the really useful utility classes Spring Rich Client provides to lay out controls and handle events.&lt;/p&gt;
&lt;p&gt;Next time, let's have a look at all those commands and executors we've seen inside the OwnerManagerView.java, and try to work all that out.&lt;/p&gt;
          
</content></entry><entry><title>Spring Richclient ~ Session Five ~ Applications, windows, views</title><category term='richclient'/><category term='java'/><category term='spring'/><category term='tutorial'/><link href='http://chrismdp.com/2006/02/spring-rc-session-five'/><updated>2006-02-03T15:21:00+00:00</updated><id>http://chrismdp.com/2006/02/spring-rc-session-five</id><content type='html'>&lt;div class='notice'&gt;&lt;h1&gt;By the way...&lt;/h1&gt;&lt;p&gt;This content is now pretty old: check &lt;a href='/'&gt;the homepage&lt;/a&gt; for the latest.&lt;/p&gt;&lt;/div&gt;
          
&lt;p&gt;Thanks to the recently discovered &lt;a href=&quot;http://opensource2.atlassian.com/confluence/spring/display/RCP/Home&quot;&gt;Spring Rich Client wiki&lt;/a&gt;, I've discoved the basic architecture of a Rich Client application. &lt;/p&gt;
&lt;p&gt;After reading the &lt;a href=&quot;http://opensource2.atlassian.com/confluence/spring/display/RCP/Introduction#Introduction-PlatformOverview&quot;&gt;platform overview section&lt;/a&gt; on the wiki, I was at a bit of a loss with all the terms, so I thought I'd better draw a diagram. I cranked up OpenOffice Draw and the GIMP, and came up with this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/files/rcp-layout.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;Basically, we've got an Application object, which contains one or more windows. Each of these contains a page, which in turn contains one or more views laid out upon it. The page manages the views, passing them lifecycle notifications and arranging them as it sees fit.&lt;/p&gt;
&lt;p&gt;Ok, that makes more sense now it's in a diagram. Let's have a look at the Petclinic application, and see how that fits into this mould.&lt;/p&gt;
&lt;p&gt;Taking a look back at our old friend richclient-application-context.xml, we can now understand Application and ApplicationDescriptor much more clearly. The ApplicationDescriptor simply defines properties of the standard Application object that's instantiated.&lt;/p&gt;
&lt;p&gt;We were correct about the PetclinicLifecycleAdvisor: it backs the Application object and allows us to control coarse-grained application behaviour. There's an example of this sort of control on &lt;a href=&quot;http://opensource2.atlassian.com/confluence/spring/display/RCP/Core+Concepts&quot;&gt;this wiki page&lt;/a&gt; which shows us how to add a confirmation window before closing the application. We've also got other examples in the PetclinicLifecycleAdvisor implementation - the &quot;setupWizard&quot; window is thrown up before the main application window is starting. See &lt;a href=&quot;/node/10&quot;&gt;Session Three&lt;/a&gt; for the code.&lt;/p&gt;
&lt;p&gt;Ok, so where in Petclinic are the main application windows defined? From running the application, we can clearly see that there's only one of them. Unfortunately looking at richclient-application-context.xml wasn't very helpful. In the end I did a search for ownerManagerView, which I figured must be added to the ApplicationPage somewhere. In my search I noticed that we pass the ownerManagerView into the Lifecycle advisor configuration:&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
	&lt;bean id=&quot;petclinicLifecycleAdvisor&quot;
		class=&quot;org.springframework.richclient.samples.petclinic.PetClinicLifecycleAdvisor&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;windowCommandBarDefinitions&quot;&gt;
			&lt;value&gt;org/springframework/richclient/samples/petclinic/ui/commands-context.xml&lt;/value&gt;
		&lt;/property&gt;
&lt;property name=&quot;startingPageId&quot;&gt;
			&lt;value&gt;ownerManagerView&lt;/value&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Interesting. Time to look up &quot;startingPageId&quot; in ApplicationLifecycleAdvisor.java. The most helpful thing we run into is the afterPropertiesSet() method. This method, if it exists, this is called by the regular Spring Framework to allow people to check values were set correctly at the time of application launch. The relevant bit of Java code is below:&lt;/p&gt;
&lt;p&gt;{% highlight Java %}
public void afterPropertiesSet() throws Exception {
  final Properties systemProperties = System.getProperties();
  if (systemProperties.get(EXCEPTION_HANDLER_KEY) == null) {
    systemProperties.put(EXCEPTION_HANDLER_KEY, getEventExceptionHandler().getName());
  }
  Assert.state(startingPageId != null,
    &quot;startingPageId must be set: it must point to a page descriptor, or a view descriptor for a single view per page&quot;);
  }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;The only relevant statement is the last one - it tells us that we need to set startingPageId to a &quot;page descriptor&quot;, or a &quot;view descriptor&quot;. I'm assuming here that Spring Rich Client uses the term &quot;descriptor&quot; classes to mean objects that describe how to set up other objects.&lt;/p&gt;
&lt;p&gt;Ok, so what code actually sets up the page? A search for getStartingPageId leads to the jackpot, in ApplicationLauncher.java:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
private void launchMyRichClient() {
  ...
  Application application = (Application)rootApplicationContext.getBean(APPLICATION_BEAN_ID, Application.class);
  application.openWindow(application.getLifecycleAdvisor().getStartingPageId());
  application.getLifecycleAdvisor().onPostStartup();
  ...
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;If I'd remembered ApplicationLauncher, I might have started there at the beginning of this session! This clearly starts the application and opens a window, passing the startingPageId (which refers to the ownerManagerView for PetClinic).&lt;/p&gt;
&lt;p&gt;Hang on a minute though: the diagram above clearly states that a window contains a page, which contains a view - you might be asking &quot;How can a window be opened with a view?&quot;. The afterPropertiesSet() error message above tells us that if you pass a view descriptor instead of a page descriptor, it'll just create a page with the one view you've described. Excellent.&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;We've learnt today how the main windows of applications are defined. It appears that creating your first main window is as simple as passing either PageDescriptor or a ViewDescriptor into the standard ApplicationLifecycleAdvisor. If you pass a PageDescriptor, an ApplicationPage will be created according to the descriptor object you pass. If, however, you pass ViewDescriptor, an ApplicationPage will be created with one view, created again according to the descriptor you passed in.&lt;/p&gt;
&lt;p&gt;Next session, we'll have a look at that &quot;ownerManagerView&quot; ViewDescriptor, take it apart, and work out how to change it.&lt;/p&gt;
</content></entry><entry><title>Spring Richclient ~ Session One ~ Beans, Shmeans and services</title><category term='richclient'/><category term='java'/><category term='spring'/><category term='tutorial'/><link href='http://chrismdp.com/2006/01/spring-rc-session-four'/><updated>2006-01-28T12:48:00+00:00</updated><id>http://chrismdp.com/2006/01/spring-rc-session-four</id><content type='html'>&lt;div class='notice'&gt;&lt;h1&gt;By the way...&lt;/h1&gt;&lt;p&gt;This content is now pretty old: check &lt;a href='/'&gt;the homepage&lt;/a&gt; for the latest.&lt;/p&gt;&lt;/div&gt;
          
&lt;p&gt;This session, let's have a brief look at some of the other in the richclient-application-context.xml file, and see if we can at least work out roughly what they're for. First however, a word about ApplicationServices.&lt;/p&gt;
&lt;h3&gt;The ApplicationServices singleton&lt;/h3&gt;
&lt;p&gt;It looks like ApplicationServices is implemented as an old fashioned singleton bean. Have a look at the method below as an example of a service initialisation performed in this class:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
    private void initImageSource() {
        try {
            this.imageSource = (ImageSource)getApplicationContext().getBean(IMAGE_SOURCE_BEAN_ID, ImageSource.class);
        }
        catch (NoSuchBeanDefinitionException e) {
            logger.info(&quot;No image source bean found in context under name '&quot; + IMAGE_SOURCE_BEAN_ID
                    + &quot;'; configuring defaults.&quot;);
            this.imageSource = new DefaultImageSource(new HashMap());
        }
    }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Most of the other services are similarly initialised. &lt;/p&gt;
&lt;p&gt;This means that ApplicationServices &lt;i&gt;looks&lt;/i&gt; for beans to help in configuring the application backbone, but doesn't &lt;i&gt;have&lt;/i&gt; to have them. If it can't find the relevant bean, it'll just create a default and use that.&lt;/p&gt;
&lt;p&gt;How is it used? Well, there are lots of calls in the code like this:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
	iconSource = Application.services().getIconSource();
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Let's dive off on a tangent for a moment. Why is this class necessary? After all, with dependency injection, why have a central singleton defining services at all? Surely various beans would simply have their dependencies wired up as and when they need them, rather than referring to a central dependency. Is this class a legacy requirement, or does it prevent us having pages of standard spring wiring XML which is inefficient, difficult to maintain, and unnecessary?&lt;/p&gt;
&lt;p&gt;I'd be interested in finding out your thoughts on this, especially if you are further along the &quot;way of the Rich Client&quot; than I - feel free to leave a comment.&lt;/p&gt;
&lt;p&gt;Right, on to some of the other beans. I feel we're getting diminishing returns from looking at these, but we'll press on with a few.&lt;/p&gt;
&lt;h3&gt;componentFactory&lt;/h3&gt;
&lt;p&gt;The componentFactory is of type DefaultComponentFactory, and is one of the Application Services mentioned in the previous section.&lt;/p&gt;
&lt;p&gt;{% highlight bash %}$ grep -nH -r componentFactory *
richclient-application-context.xml:53:	&lt;bean id=&quot;componentFactory&quot;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Searching for files which access ApplicationServices' getComponentFactory() method turns up a whole bunch of results in the Rich Client source, but not very much in the Petclinic source. Looks like the component factory is used to create components all over the place in the main Rich Client source. I'm guessing that the Petclinic does not require the ability to create many components - and a quick look at some of the code confirms this to be the case. More on this later.&lt;/p&gt;
&lt;h3&gt;imageSource&lt;/h3&gt;
&lt;p&gt;Here's the &quot;imageSource&quot; bean definition:&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
	&lt;bean id=&quot;imageSource&quot;
		class=&quot;org.springframework.richclient.image.DefaultImageSource&quot;&gt;
		&lt;constructor-arg index=&quot;0&quot;&gt;
			&lt;ref bean=&quot;imageResourcesFactory&quot;/&gt;
		&lt;/constructor-arg&gt;&lt;/p&gt;
&lt;property name=&quot;brokenImageIndicator&quot;&gt;
			&lt;value&gt;images/alert/error_obj.gif&lt;/value&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;This provides a &quot;broken image indicator&quot; path - useful, so we can actually see the dodgy images like on a web page, rather than just having invisible ones). &lt;/p&gt;
&lt;p&gt;The bean references imageResourcesFactory, which create a Map of strings to resource locations, for the imageSource bean to use, from a couple more properties files.&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
	&lt;bean id=&quot;imageResourcesFactory&quot;
		class=&quot;org.springframework.context.support.ResourceMapFactoryBean&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;locations&quot;&gt;
&lt;list&gt;
				&lt;value&gt;classpath:org/springframework/richclient/image/images.properties&lt;/value&gt;
				&lt;value&gt;classpath:org/springframework/richclient/samples/petclinic/ui/images.properties&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
&lt;property name=&quot;resourceBasePath&quot;&gt;
			&lt;value&gt;images/&lt;/value&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;There's another &quot;standard&quot; Rich Client properties file here (just as there was one for the messageSource bean last session) which defines paths for basic icons (like those for &quot;New&quot;, &quot;Open&quot;, &quot;Save&quot; etc). These ship in spring-richclient-resources.jar, so you can use them out of the box. If you don't want to, simply define your own icon location with the same name in your own images.properties. Easy.&lt;/p&gt;
&lt;h3&gt;applicationEventMulticaster&lt;/h3&gt;
&lt;p&gt;This one looks straightforward - it appears to simply be the event transport for the application context, and is part of standard Spring from the classpath. That looks to be how events are passed around the application.&lt;/p&gt;
&lt;h3&gt;rulesSource&lt;/h3&gt;
&lt;p&gt;This seems to provide sets of rules to use when validating entered data. Looking at the source for PetClinicValidationRulesSource, the class being instantiated, it sets up certain constraints for the owner and pet data that is entered into the app. More on this in a future session, when we create our own data entry box.&lt;/p&gt;
&lt;h3&gt;And... stop&lt;/h3&gt;
&lt;p&gt;Right, that's enough. Apart from the ui beans which we'll cover next session, the other beans all look far too scary. Plus, I'm bored with looking at XML. I think we'll learn more going forward by looking at some of the windows, views and dialogs represented by the GUI beans.&lt;/p&gt;
&lt;p&gt;Mmm. GUI beans. Now there's a thought.&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;We've come some way today in understanding the Rich Client architecture, and how the core ApplicationServices code initialises and configures itself. We discussed the ApplicationServices class and it's usefulness/right to exist, without really knowing the answer. Comments welcome.&lt;/p&gt;
&lt;p&gt;We also went through a few more of the beans in the richclient-application-context.xml and didn't learn all that much, apart from one important thing - we've come to the end of this file's usefulness in teaching us anything new.&lt;/p&gt;
&lt;p&gt;Next session: windows, views, dialog boxes and perhaps even a field or two.&lt;/p&gt;
</content></entry><entry><title>Spring Richclient ~ Session Three ~ How did that work then?</title><category term='richclient'/><category term='java'/><category term='spring'/><category term='tutorial'/><link href='http://chrismdp.com/2006/01/spring-rc-session-three'/><updated>2006-01-26T23:09:00+00:00</updated><id>http://chrismdp.com/2006/01/spring-rc-session-three</id><content type='html'>&lt;div class='notice'&gt;&lt;h1&gt;By the way...&lt;/h1&gt;&lt;p&gt;This content is now pretty old: check &lt;a href='/'&gt;the homepage&lt;/a&gt; for the latest.&lt;/p&gt;&lt;/div&gt;
          
&lt;p&gt;At the end of the last session, we'd managed to get the Petclinic application up and running in its own directory, and located the main configuration file (richclient-application-context.xml). We'd also worked out what a few beans in there actually did, although there were many more still to look at. In the next couple of sessions, I'm going to have a closer look at the Rich Client specific beans in richclient-application-context.xml and work out what they do. &lt;/p&gt;
&lt;p&gt;This session, let's find out how my &quot;Hello, world!&quot; change actually worked, by following the bean definitions through richclient-application-context.xml. We might even learn something about the Rich Client architecture on the way. Here goes...&lt;/p&gt;
&lt;h3&gt;The Lifecycle Advisor&lt;/h3&gt;
&lt;p&gt;The setup wizard from last session came up as the first thing after the splash screen, right? What controls in a Rich Client application which windows come up in which order? Let's do a search for setupWizard in the petclinic code and see what we come up with...&lt;/p&gt;
&lt;p&gt;{% highlight bash %}
$ grep -nH -r setupWizard *
PetClinicLifecycleAdvisor.java:33:        if (getApplicationServices().containsBean(&quot;setupWizard&quot;)) {
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Aha. We briefly mentioned the lifecycle advisor last session and labelled it as an &quot;application flow controller&quot;. This is beginning to make sense.&lt;/p&gt;
&lt;p&gt;Looking at the source code for this object, I'm guessing the following method is called just before the main window of the application is opened:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
    public void onPreWindowOpen(ApplicationWindowConfigurer configurer) {
        super.onPreWindowOpen(configurer);
        if (getApplicationServices().containsBean(&quot;setupWizard&quot;)) {
            SetupWizard setupWizard = (SetupWizard)getApplicationServices().getBean(&quot;setupWizard&quot;, SetupWizard.class);
            setupWizard.execute();
        }
		...
    }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Ok, so the &quot;setupWizard&quot; bean is searched for and &quot;executed&quot;. Let's have a look at this bean.&lt;/p&gt;
&lt;h3&gt;The &quot;setupWizard&quot; bean&lt;/h3&gt;
&lt;p&gt;Here's the bean configuration from richclient-application-context.xml:&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
	&lt;bean id=&quot;setupWizard&quot;
		class=&quot;org.springframework.richclient.application.setup.SetupWizard&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;licenseTextLocation&quot;&gt;
			&lt;value&gt;/org/springframework/richclient/samples/petclinic/license.html&lt;/value&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;This is a simple bean to configure, a stock component of the Rich Client framework (from the class path), taking some license text from the petclinic application. So far, so good. Let's do what we did at the end of the last session in a little more detail, and look under the hood at SetupWizard.java. How does it create that first page?&lt;/p&gt;
&lt;p&gt;{% highlight java %}
    public void addPages() {
        addPage(new SetupIntroWizardPage());
        addPage(licensePage);
    }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;This addPages() method must be called at some point during creation ... and the first page is a SetupIntroWizardPage. Looking at SetupIntroWizardPage.java, we find the key for &quot;setup.intro.description&quot;.&lt;/p&gt;
&lt;p&gt;{% highlight java %}
    private JLabel createDescriptionLabel() {
        return new JLabel(LabelUtils.htmlBlock(getMessage(&quot;setup.intro.description&quot;)));
    }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;That getMessage() method took quite a while to find - it can be traced right back to ApplicationServicesAccessor.java, a distant ancestor of this class:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
    protected String getMessage(String messageCode) {
        return getApplicationContext().getMessage(messageCode, null, messageCode, Locale.getDefault());
    }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;This calls getMessage() on the application context. In a standard application context object, such as ours, this method looks for a bean with name &quot;messageSource&quot; and attempts to resolve the message key. Let's have a look at the &quot;messageSource&quot; bean next.&lt;/p&gt;
&lt;h3&gt;The &quot;messageSource&quot; bean&lt;/h3&gt;
&lt;p&gt;{% highlight xml %}
	&lt;bean id=&quot;messageSource&quot;
		class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;basenames&quot;&gt;
&lt;list&gt;
				&lt;value&gt;org.springframework.richclient.samples.petclinic.ui.messages&lt;/value&gt;
				&lt;value&gt;org.springframework.richclient.application.messages&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Familiar Spring territory here. This is a standard Spring ResourceBundleMessageSource. Check the javadocs for ResourceBundleMessageSource if you need more explanation of this one.&lt;/p&gt;
&lt;p&gt;Give the above configuration, ResourceBundleMessageSource will try these locations in this order to find the message key we supply:&lt;/p&gt;
&lt;p&gt;{% highlight text %}
./src/org/springframework/richclient/samples/petclinic/ui/messages_&lt;language&gt;.properties
   (so messages_fr.properties if we have a french locale)
./src/org/springframework/richclient/samples/petclinic/ui/messages.properties
./src/org/springframework/richclient/application/messages_&lt;language&gt;.properties
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;The last path here refers to a &quot;standard&quot; Rich Client properties files which ships with the Rich Client framework. Looking inside, this defines words for things like &quot;File&quot;, &quot;Edit&quot;, &quot;Paste&quot;, and standard icons used in many applications. The really neat thing is that these are already translated into French, German and Dutch for me, which gives me a whole lot of localisation for free! This framework really is awesome.&lt;/p&gt;
&lt;p&gt;Oh look, we've traced our message back through the bean hierarchy. That wasn't too bad at all, was it?&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;A quick summary of what we've learnt in this session:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The petclinic lifecycle advisor controls when windows appear when the application runs, and most likely can be used for many other things.&lt;/li&gt;
&lt;li&gt;The standard spring &quot;messageSource&quot; bean is used by standard Rich Client objects such as SetupWizard to resolve message keys.&lt;/li&gt;
&lt;li&gt;Rich Client provides many standard messages for you, pre-localised in four languages. Neat.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Much of spring configuration we've looked at today looks like boilerplate xml to me - I don't think I'll need to change much at all. The only thing that looks like it needs changing here are the application specific messages.properties files, so that I can add the messages I want to appear.&lt;/p&gt;
&lt;p&gt;Next session, we'll have a look at some of the other beans which use &quot;messageSource&quot;.&lt;/p&gt;
</content></entry><entry><title>Spring Richclient ~ Session Two ~ Hello World</title><category term='richclient'/><category term='java'/><category term='spring'/><category term='tutorial'/><link href='http://chrismdp.com/2006/01/spring-rc-session-two'/><updated>2006-01-24T14:40:00+00:00</updated><id>http://chrismdp.com/2006/01/spring-rc-session-two</id><content type='html'>&lt;div class='notice'&gt;&lt;h1&gt;By the way...&lt;/h1&gt;&lt;p&gt;This content is now pretty old: check &lt;a href='/'&gt;the homepage&lt;/a&gt; for the latest.&lt;/p&gt;&lt;/div&gt;
          
&lt;p&gt;Ok. Today, it's time to look under the hood.&lt;/p&gt;
&lt;p&gt;Firstly, I decided to move the petclinic application to its own directory and clean up the paths a bit so that they reflected the usual way I organise java applications. Also, I wanted this to be a standalone application and therefore I needed to remove some of the relative paths in project.properties so that we didn't need the Rich Client source around to compile and run it. Finally, to satisfy my TDD cravings, I added junit test build targets in and created a dummy test to ensure junit was up and running. &lt;/p&gt;
&lt;p&gt;After fixing a number of little build.xml bugs, I got the project compiling again in its own directory. So far, so good. Right, time to look at how this all works. &lt;/p&gt;
&lt;p&gt;A look at the build.xml shows that the petclinic-standalone.jar we ran in the first session uses PetClinicStandalone.java as its entry point, so let's start with that:&lt;/p&gt;
&lt;p&gt;{% highlight java %}
public class PetClinicStandalone {
    public static void main(String[] args) {
        try {
            String rootContextDirectoryClassPath = &quot;/org/springframework/richclient/samples/petclinic/ctx&quot;;
            String startupContextPath = rootContextDirectoryClassPath + &quot;/common/richclient-startup-context.xml&quot;;
            String richclientApplicationContextPath = rootContextDirectoryClassPath
                    + &quot;/common/richclient-application-context.xml&quot;;
            String businessLayerContextPath = rootContextDirectoryClassPath + &quot;/common/business-layer-context.xml&quot;;
            String securityContextPath = rootContextDirectoryClassPath + &quot;/standalone/security-context.xml&quot;;
            new ApplicationLauncher(startupContextPath, new String[] { richclientApplicationContextPath,
                    businessLayerContextPath, securityContextPath });
        } catch (Exception e) {
            System.exit(1);
        }
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Ok, that looks straightforward. We hard code a number of paths to what look like XML files of spring beans, and pass them into an &quot;ApplicationLauncher&quot;. They're split into two groups: the &quot;startup context file&quot;, and an array of &quot;the other context files&quot;.&lt;/p&gt;
&lt;h3&gt;The startup context&lt;/h3&gt;
&lt;p&gt;I'm guessing a &quot;startup context file&quot; contains special beans to help with the startup of the application. A quick look at ApplicationLauncher.java confirms this; the javadoc for the constructor reads:&lt;/p&gt;
&lt;p&gt;{% highlight html %}
Launch the application using the spring application context
at the provided paths for configuration. The startup context
path is loaded first to allow for quick loading of the
application splash screen.
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Excellent. That must be what stuck that frog picture on my screen in session one. Let's have a look at the richclient-startup-context.xml file:&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
  &lt;beans&gt;
    &lt;bean id=&quot;splashScreen&quot; class=&quot;org.springframework.richclient.application.SplashScreen&quot; singleton=&quot;false&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;imageResourcePath&quot;&gt;
        &lt;value&gt;/images/splash-screen.jpg&lt;/value&gt;
      &lt;/property&gt;
    &lt;/bean&gt;
  &lt;/beans&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;A little more digging in the code shows that that &quot;splashScreen&quot; bean is actually a hard coded bean name in the ApplicationLauncher, so I guess if you want a splash screen in your application, just do exactly as the sample does.&lt;/p&gt;
&lt;p&gt;At this point a strong temptation to vandalise splash-screen.jpg with a cheeky &quot;Hello, world!&quot; came over me (that would satisfy my brief for this session in one go, right?). But we wouldn't learn much from that, and I feel like I'm on a roll here. &lt;/p&gt;
&lt;p&gt;Right, what about those other application context files? More looking through ApplicationLauncher.java shows me that they're piped into a good ol' ClassPathXmlApplicationContext, familiar to Spring aficionados the world over. One application context is created from all the files: I guess they're split up into different files so different variants of Petclinic (I'm thinking client/server here) can mix and match different beans as they wish.&lt;/p&gt;
&lt;p&gt;Let's look at each of these files in turn: &lt;/p&gt;
&lt;h3&gt;security-layer-context.xml&lt;/h3&gt;
&lt;p&gt;This file contains a bunch of familiar looking ACEGI Security beans. I'm not going into the details of setting up ACEGI security - being a totally non-invasive security architecture, if you don't want it you shouldn't have to worry about it. At least, that's true for 'regular' Spring, and I'm guessing that it'll be the same here too.&lt;/p&gt;
&lt;h3&gt;business-layer-context.xml&lt;/h3&gt;
&lt;p&gt;This is familiar territory for anyone using spring for web applications. We find a data source (petclinic uses HSQL to store its data), a transaction manager, and a DAO in the form of a &quot;clinic&quot; bean. No suprises here.&lt;/p&gt;
&lt;h3&gt;richclient-application-context.xml&lt;/h3&gt;
&lt;p&gt;That leaves us with richclient-application-context.xml, which is all new. I have to say at this point I baulked slightly at the sheer number of new beans to learn. But hey, somebody wrote it, so someone must understand it, right? Therefore it must be possible to figure it out... &lt;/p&gt;
&lt;p&gt;With that in mind, let's start with the first three beans:&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
  &lt;bean id=&quot;application&quot;
    class=&quot;org.springframework.richclient.application.Application&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot;&gt;
      &lt;ref bean=&quot;applicationDescriptor&quot;/&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg index=&quot;1&quot;&gt;
      &lt;ref bean=&quot;petclinicLifecycleAdvisor&quot;/&gt;
    &lt;/constructor-arg&gt;
  &lt;/bean&gt;&lt;/p&gt;
&lt;p&gt;  &lt;bean id=&quot;applicationDescriptor&quot;
    class=&quot;org.springframework.richclient.application.support.DefaultApplicationDescriptor&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;version&quot;&gt;
      &lt;value&gt;1.0&lt;/value&gt;
    &lt;/property&gt;
&lt;property name=&quot;buildId&quot;&gt;
      &lt;value&gt;20041025001&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;&lt;/p&gt;
&lt;p&gt;  &lt;bean id=&quot;petclinicLifecycleAdvisor&quot;
    class=&quot;org.springframework.richclient.samples.petclinic.PetClinicLifecycleAdvisor&quot;&gt;&lt;/p&gt;
&lt;property name=&quot;windowCommandBarDefinitions&quot;&gt;
      &lt;value&gt;org/springframework/richclient/samples/petclinic/ui/commands-context.xml&lt;/value&gt;
    &lt;/property&gt;
&lt;property name=&quot;startingPageId&quot;&gt;
      &lt;value&gt;ownerManagerView&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;From looking at ApplicationLauncher, &quot;application&quot; is a &quot;magic name&quot; for a bean - that is, the framework looks specifically for a bean called &quot;application&quot; in one of its XML files. It's set up with two other beans - applicationDescriptor and a lifecycle advisor. ApplicationDescriptor looks very straightforward - a version and a build number. I'm guessing that goes in the title, and perhaps an automated &quot;Help - About&quot; screen later on (here's hoping, anyway :).&lt;/p&gt;
&lt;p&gt;The lifecycle advisor looks a little more involved. It appears to be configured with another xml file, which I'll look at in a bit, and a &quot;starting page id&quot; which refers to an &quot;owner manager view&quot;. Looking at ApplicationLauncher (again), it appears that on launch a window is opened with this &quot;owner manager view&quot; page displayed first. After that, onPostStartup() is called on the lifecycle advisor. &lt;/p&gt;
&lt;p&gt;From this it looks like the lifecycle advisor is used here as the application flow manager. The two methods overridden for the petclinic application look like they create the Setup Wizard and the login screen. I guess that there are many things one could add to this to perform custom actions at various points within the application.&lt;/p&gt;
&lt;h3&gt;Look and Feel&lt;/h3&gt;
&lt;p&gt;At this point I notice that the JGoodies support I raved about earlier is neatly encapsulated in one bean:&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
  &lt;bean id=&quot;lookAndFeelConfigurer&quot;
    class=&quot;org.springframework.richclient.application.config.JGoodiesLooksConfigurer&quot;&gt;
&lt;property name=&quot;popupDropShadowEnabled&quot; value=&quot;false&quot; /&gt;
&lt;property name=&quot;theme&quot;&gt;
      &lt;bean class=&quot;com.jgoodies.looks.plastic.theme.ExperienceBlue&quot;/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Searching through the Rich Client codebase turns up another magic bean name in ApplicationServices.java:&lt;/p&gt;
&lt;p&gt;{% highlight java %}public static final String LOOK_AND_FEEL_CONFIGURER_BEAN_ID = &quot;lookAndFeelConfigurer&quot;;{% endhighlight %}&lt;/p&gt;
&lt;p&gt;There's a whole lot of other magic bean names in there - if you are wondering what to name a bean, that's a good place to start looking!&lt;/p&gt;
&lt;h3&gt;Changing the Setup Wizard&lt;/h3&gt;
&lt;p&gt;Most of the rest of the beans I think I'll have to leave for this session, save the last one - the &quot;setupWizard&quot;:&lt;/p&gt;
&lt;p&gt;{% highlight xml %}
  &lt;bean id=&quot;setupWizard&quot;
    class=&quot;org.springframework.richclient.application.setup.SetupWizard&quot;&gt;
&lt;property name=&quot;licenseTextLocation&quot;&gt;
      &lt;value&gt;/org/springframework/richclient/samples/petclinic/license.html&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;If I can modify the wizard to show a &quot;Hello, World!&quot; page, then I'll be happy. &lt;/p&gt;
&lt;p&gt;Looking at the code for SetupWizard, I notice that it adds a SetupIntroWizardPage object. This object references a number of messages, including &quot;setup.intro.description&quot;. Hah! I remembered that richclient-application-context.xml had some references to &quot;message source&quot; type beans, but rather than work all that stuff out at this stage, I cheat and search the whole source tree for &quot;setup.intro.description&quot;. This turns up a reference in petclinic/ui/messages.properties:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setup.intro.description=The petclinic sample application
demonstrates the base capabilities  of Spring's Rich Client
Project, built on standard J2SE Swing.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Right, time to fulfill the brief:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setup.intro.description=Hello, world!  This page shows
that I can trivially change a text file and by making text appear
differently, I can impress my peers without really knowing what I'm
doing.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A quick recompile, and here's the result:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/files/spring-richclient-2-1.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;It's not that impressive, I grant you. But at least it shows that if a Rich Client application is written correctly, you can leverage Spring's built in message support. This is vital for things like localisation.&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;A quick summary of what we've learnt in this session:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To launch a Spring Richclient Application, you use some boilerplate code in a standard main() method to initialise an ApplicationLauncher with some Spring beans XML files.&lt;/li&gt;
&lt;li&gt;You may include an optional startup XML file containing one specially named bean for a splash screen.&lt;/li&gt;
&lt;li&gt;Many Rich Client specific beans in the XML files are specially named and are probably required to be present. This means I'll most likely copy the Rich Client specific file and modify it, rather than creating from scratch.&lt;/li&gt;
&lt;li&gt;Look and feel configuration is trivially handled through a specially named bean in the XML configuration files.&lt;/li&gt;
&lt;li&gt;The setup wizard shipped with the Rich Client framework uses standard spring messaging by default, allowing us to trivially customise the text.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Next session, we'll look at some those of the other beans in richclient-application-context.xml and work out what on earth they're for. Stay tuned.&lt;/p&gt;
</content></entry><entry><title>Spring Richclient ~ Session One ~ Making Petclinic work</title><category term='richclient'/><category term='java'/><category term='spring'/><category term='tutorial'/><link href='http://chrismdp.com/2006/01/spring-rc-session-one'/><updated>2006-01-23T14:31:00+00:00</updated><id>http://chrismdp.com/2006/01/spring-rc-session-one</id><content type='html'>&lt;div class='notice'&gt;&lt;h1&gt;By the way...&lt;/h1&gt;&lt;p&gt;This content is now pretty old: check &lt;a href='/'&gt;the homepage&lt;/a&gt; for the latest.&lt;/p&gt;&lt;/div&gt;
          
&lt;p&gt;Right, here goes.&lt;/p&gt;
&lt;p&gt;Initially I wasn't sure where to begin. I searched for &quot;Spring Rich Client&quot; on google, looking for a tutorial and found zero. I found the &lt;a href=&quot;http://www.springframework.org/spring-rcp&quot;&gt;Rich Client homepage&lt;/a&gt; on the spring site, which was a start, and read the rather text-heavy introduction carefully.&lt;/p&gt;
&lt;p&gt;I was rather suprised at this point that there wasn't an alpha release to download, but never mind, I suppose the framework is still in early development; and hey, I'm supposed to be a coder, and coders can handle checking out CVS, right? :)&lt;/p&gt;
&lt;p&gt;Armed with an appropriate sense of coder machismo, I headed off to the sourceforge pages and checked out the code. Hit a hurdle trying to find the correct module name (spring-richclient, by the way - it's not mentioned on the webpage), but got there in the end by browsing the Sourceforge repository.&lt;/p&gt;
&lt;p&gt;{% highlight bash %}$ cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/spring-rich-c login{% endhighlight %}&lt;/p&gt;
&lt;p&gt;{% highlight bash %}$ cvs -z3 -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/spring-rich-c co -P spring-richclient{% endhighlight %}&lt;/p&gt;
&lt;p&gt;This got me the code, which looked to be a standard java project buildable with ant. Time to fire up emacs (I'm a JDE freak, away you Eclipse acolytes with your fancy iconry and easy-to-use plugins):&lt;/p&gt;
&lt;p&gt;{% highlight bash %}M-x jde-ant-build / build{% endhighlight %}&lt;/p&gt;
&lt;p&gt;So far, so good. Lots of text whirred past and I've built a version of the latest framework and packages it into three nice jars in the 'dist' directory. I've still no idea what anything does, but I'm feeling good at this point. I'm even brave enough to try running the unit tests...&lt;/p&gt;
&lt;p&gt;{% highlight bash %}M-x jde-ant-build / test{% endhighlight %}&lt;/p&gt;
&lt;p&gt;More whirring text. There are lots of tests passing, which is encouraging to a TDD fanboy. Most seem to pass without a hitch, I'm rather encouraged, then I see one failure:&lt;/p&gt;
&lt;p&gt;{% highlight bash %}Test org.springframework.richclient.security.support.DefaultSecurityControllerManagerTests FAILED{% endhighlight %}&lt;/p&gt;
&lt;p&gt;I haven't a clue what a DefaultSecurityControllerManager is, and decide to ignore it completely at this stage. I figure that if I encounter a problem later, I'll do a cvs update and see if that tests was fixed, and try again, then post to the Spring forum if it still doesn't work.&lt;/p&gt;
&lt;p&gt;So, onto the sample application. I find a samples directory which contains 'petclinic' - most encouraging. Another build.xml - excellent:&lt;/p&gt;
&lt;p&gt;{% highlight bash %}M-x jde-ant-build / usage
Petclinic Rich sample application build file
------------------------------------------------------
Available targets are:
clean  --&gt; Clean output dirs
build  --&gt; Compile main Java sources and copy libraries
build-standalone  --&gt; Compile standalone main Java sources and copy libraries
warfile  --&gt; Create WAR deployment units
javadoc  --&gt; Create API documentation
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Hmm. Clean, build and javadoc I understand, but what's with the standalone and warfile variants? This is initially rather confusing, as I figured that there wouldn't be any need to run a web application to use Spring Rich Client. I peer at the build.xml file for a bit longer, until I see the Java Web Start (JWS) references and figure the web application must just be to demonstrate a Rich Client application running through JWS.&lt;/p&gt;
&lt;p&gt;(Note: it's only later that I saw that you need a web application because petclinic can be a client-server application - this wasn't at all clear on first read. Perhaps two samples would be clearer, rather&lt;br /&gt;
than combining both in the same place? Or perhaps a simple &quot;Hello, World?&quot; application would bridge the gap?)&lt;/p&gt;
&lt;p&gt;I decided to take one step at a time and forget about JWS for now:&lt;/p&gt;
&lt;p&gt;{% highlight bash %}M-x jde-ant-build / build{% endhighlight %}&lt;/p&gt;
&lt;p&gt;More whirring text, with the petclinic jar placed in the 'dist' directory. Excellent - it seems all is well so far and I didn't need the web application stuff. Ok, let's give it a go. Thinking that it's ten to one I've missed something, I try:&lt;/p&gt;
&lt;p&gt;{% highlight bash %}$ java -jar petclinic-standalone.jar{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Ooo. A splash screen. A frog, even better. And then, to my great delight:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/files/spring-rcp-1.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Wow. &lt;a href=&quot;http://www.jgoodies.com&quot;&gt;JGoodies&lt;/a&gt; support right out of the box. I couldn't have hoped for anything better.&lt;/p&gt;
&lt;p&gt;After clicking next a few times, and bypassing the login screen with a &quot;Cancel&quot;, I get:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/files/spring-rcp-2.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Wonderful. I've now got the source code compiling and I've a sample application I can tweak and see what happens - the only way I can really learn anything. I'm set.&lt;/p&gt;
&lt;p&gt;A couple of thoughts before I close out this session. Firstly it's clear the bad old days of ugly java apps are over. I'm blown away by how good the application looks, for a java application. That's partly due to the wonders of JGoodies, but it looks like Spring Rich Client is going to help me produce a lovely looking application for the client. Excellent.&lt;/p&gt;
&lt;p&gt;Secondly, I'm pleased that there really weren't that many steps for the average java developer who's used to ant to go through before getting this working. The only real hurdles were finding the right CVS module, and deciphering the ant build targets which at first glance are rather impeneterable. I'm also pleased it compiled straight from CVS and (almost) all the tests passed; a failing build, and I would have mostly likely given up there and then.&lt;/p&gt;
&lt;p&gt;Coming soon: &quot;Session Two: Hello, world!&quot;&lt;/p&gt;

</content></entry><entry><title>Spring Richclient ~ Introduction</title><category term='richclient'/><category term='java'/><category term='spring'/><category term='tutorial'/><link href='http://chrismdp.com/2006/01/spring-rc-introduction'/><updated>2006-01-23T12:36:00+00:00</updated><id>http://chrismdp.com/2006/01/spring-rc-introduction</id><content type='html'>&lt;div class='notice'&gt;&lt;h1&gt;By the way...&lt;/h1&gt;&lt;p&gt;This content is now pretty old: check &lt;a href='/'&gt;the homepage&lt;/a&gt; for the latest.&lt;/p&gt;&lt;/div&gt;
          
&lt;p&gt;Right, time to learn Spring Rich Client.&lt;/p&gt;
&lt;p&gt;I've been meaning to learn this project for a while, but haven't yet quite got round to it. Now is the time. A client wants a piece of work done that see
ms very well suited to using this framework, and it's an ideal time to work it all out.&lt;/p&gt;
&lt;p&gt;Initial viewing of the project shows that there's very little in the way of documentation for the project (well, none, actually), so I'm going to attempt
 to document my documentation-less journey into the depths of the framework. When I look back, a sort of tutorial may even have emerged, which might help ot
hers. You never know.&lt;/p&gt;
&lt;p&gt;If you notice that I'm doing this or that wrong, please feel free to post a comment and correct me. I don't care about looking amateurish or anything lik
e that, and it'll turn this into a better reference.&lt;/p&gt;
&lt;p&gt;Coming soon: &quot;Session One: Making Petclinic work&quot;&lt;/p&gt;
</content></entry></feed>
