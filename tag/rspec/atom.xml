---
layout: nil
---
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Chris Parsons: posts tagged rspec</title>

  <link href="http://chrismdp.com/"/>
  <updated>2011-10-17T19:10:29+01:00</updated>
  <id>http://chrismdp.com/tag/rspec</id>
  <author>
    <name>Chris Parsons</name>
    <email>chrismdp@gmail.com</email>
  </author>
<entry><title>Your tests are lying to you</title><category term='code'/><category term='cucumber'/><category term='craftsmanship'/><category term='bdd'/><category term='rspec'/><category term='rails'/>    <author>
      <name>Chris Parsons</name>
      <email>chrismdp@gmail.com</email>
    </author>
<link href='http://chrismdp.com/2011/10/your-tests-are-lying-to-you'/><updated>2011-10-17T19:10:29+01:00</updated><id>http://chrismdp.com/2011/10/your-tests-are-lying-to-you</id><content type='html'>&lt;p&gt;Using mocks within your test suite has gone rather out of fashion. Programmers everywhere have been lamenting the fact that mock-based tests are becoming more and more brittle: they’re having to change the test code in multiple places each time there’s the slightest code change. In fact, they seem to be changing the test code much much more often than the production code.&lt;/p&gt;

&lt;p&gt;Using mocks appear to require a lot of set up code for the object under test. Why not just fire up Factory Girl, create a bunch of objects we need to test this code, and just check the outputs?&lt;/p&gt;

&lt;p&gt;This works, and appears to work nicely. For a while.&lt;/p&gt;

&lt;p&gt;Eventually your tests will get to the point where they’re lying to you: they’re telling you your code works whereas actually it only works by coincidence. This post will examine the different techniques we can use to test code, and why some work better than others in the long term.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The problem&lt;/h2&gt;

&lt;p&gt;To look at this further, let’s try to write a conference simulator for a new website that tries to predict how many people might attend an upcoming event: &lt;/p&gt;

&lt;p&gt;{% highlight ruby %}
describe Conference do
  it “calculates total rating” do
    conference = Conference.new(:total_rating =&amp;gt; 9)
    conference.total_rating.should == 9
  end
end
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;A simple start, with equally simple production code. Next, we decide to extract our code for calculating the rating into &lt;code&gt;Speaker&lt;/code&gt; classes. We decide not to change the test suite much, and make the code work behind the scenes:&lt;/p&gt;

&lt;p&gt;{% highlight ruby %}
describe Conference do
  it “calculates total rating” do
    conference = Conference.new(:speakers =&amp;gt; [:chris, :paul])
    conference.total_rating.should == 9
  end
end
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;A nice simple, easy change? You’ll pay for this later. Where is the Speaker coming from? Your Conference class is creating it somewhere, or retrieving it from a factory. You’ve increased the number of collaborators for this class by at least one (possibly three), yet your test isn’t showing the additional complexity. It’s deceitfully hiding it, whilst you continue on in blissful ignorance.&lt;/p&gt;

&lt;p&gt;Your tests are now sitting around the outside of your system. There are no tests for the Speaker class at all, except that we co-incidentally check the rating it emits. Another developer is likely to miss the connection and remove the implied test whilst changing the code for a different reason later.&lt;/p&gt;

&lt;p&gt;This gets worse over time:&lt;/p&gt;

&lt;p&gt;{% highlight ruby %}
describe Conference do
  it “calculates total rating” do
    conference = Conference.new(
      :schedule =&amp;gt; :nine_to_five,
      :talks =&amp;gt; [talk_for(:chris), talk_for(:paul)]
    )
    conference.total_rating.should == 9
  end
end
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Can you see what’s going on here? We’ve created some nice helper methods to make it easy to create the required talk objects we need. This test is fairly easy to read, but it’s dressing up the problem. The test code is relying on far too many collaborators to function correctly to return the correct result.&lt;/p&gt;

&lt;p&gt;When you extract a class, your purely state based tests don’t always require change. If you’re not stubbing out or mocking systems, you can end up in a situation where you’re relying on the code to work without realising it.&lt;/p&gt;

&lt;p&gt;How could it be improved?&lt;/p&gt;

&lt;p&gt;{% highlight ruby %}
describe Conference do
  let(:talk1) { double(:talk, :rating =&amp;gt; 10) }
  let(:talk2) { double(:talk, :rating =&amp;gt; 6) }
  let(:schedule) { double(:schedule, :rating =&amp;gt; 10) }
  before(:each) { Schedule.stub(:new =&amp;gt; schedule) }
  it “calculates total rating” do
    conference = Conference.new(
      :schedule =&amp;gt; :nine_to_five,
      :talks =&amp;gt; [talk1, talk2]
    )
    conference.total_rating.should == 9
  end
end&lt;/p&gt;

&lt;p&gt;describe Speaker do
end
describe Schedule do
end
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Now we’ve isolated the method nicely from its collaborators, and ensured that its behaviour is correct: that it aggregates the ratings of the talks and the schedule. We also make sure that we’re testing Conference correctly, also in isolation.&lt;/p&gt;

&lt;p&gt;The more you use refactoring methods such as Extract Class without cleaning up your tests, the more likely your tests will be lying to you. Little by little, those tests that you trusted are slowly testing more and more code. You add a multitude of edge cases at the edges, never thinking about the complexity within. You’ve resorted to using end-to-end tests to test basic correctness.&lt;/p&gt;

&lt;p&gt;This is a bad thing on many levels: for example, what happens to interface discovery? How will you know how the interface of your lower-level classes needs to behave if you’re not mocking or stubbing it? You are resorting to guessing, rather than exercising the interface ahead of time in your tests. If you have tests around the edges, but not in the middle, you’re not gaining the design input that tests give you in each layer of your system.&lt;/p&gt;

&lt;h2 id=&quot;your-code-stinks&quot;&gt;Your code stinks&lt;/h2&gt;

&lt;p&gt;If you go the whole hog with testing in isolation, then you might end up here with something like this:&lt;/p&gt;

&lt;p&gt;{% highlight ruby %}
describe Conference do
  let(:talk1) { double(:talk, :rating =&amp;gt; 10) }
  let(:talk2) { double(:talk, :rating =&amp;gt; 6) }
  let(:talk3) { double(:talk, :rating =&amp;gt; 2) }
  let(:talk4) { double(:talk, :rating =&amp;gt; 8) }
  let(:track1) { double(:track, :talks =&amp;gt; [talk1, talk3] }
  let(:track2) { double(:track, :talks =&amp;gt; [talk2, talk4] }&lt;/p&gt;

&lt;p&gt;let(:venue1) { double(:venue, :nice_coffee_places =&amp;gt; 3) }&lt;/p&gt;

&lt;p&gt;let(:joe) { double(:announcer, :experience =&amp;gt; 5) }&lt;/p&gt;

&lt;p&gt;let(:schedule) { double(:schedule, :rating =&amp;gt; 10, :accouncer =&amp;gt; joe) }
  before(:each) { Schedule.stub(:new =&amp;gt; schedule) }&lt;/p&gt;

&lt;p&gt;it “calculates total rating” do
    conference = Conference.new(
      :schedule =&amp;gt; :nine_to_five,
      :tracks =&amp;gt; [track1, track2],
      :organiser =&amp;gt; joe,
      :venues =&amp;gt; [venue1, venue1]
    )
    conference.total_rating.should == 6.3945820
  end
end&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;I’m not surprised people moan about maintaining this: if any aspect of the Conference class changes, this test will break and need to be fixed. We can see that this test code is hard to write and difficult to read. It would be so much easier just to hide this setup in a few factory methods with some sensible defaults, right?&lt;/p&gt;

&lt;p&gt;Maybe it’s not the test code that’s the problem. Perhaps the code stinks. Perhaps the class simply has way too many collaborators, which is why your test code contains a large amount of set up.&lt;/p&gt;

&lt;p&gt;For this test code, we can see there are several objects leaking all over the conference code: to refactor this I’d probably get through a Scheduler, Caterer and perhaps a TrackAggregator before I was done. I’d ensure all these objects were tested in isolation, and ensure that there are acceptance tests all the way through to make sure the customer has what they need.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Well designed code is easy to test.&lt;/em&gt; As a rule of thumb, anytime I get over about two or three lines of setup code for testing a method, I normally take a step back and ask myself if this method is doing too much.&lt;/p&gt;

&lt;h2 id=&quot;test-speed&quot;&gt;Test speed&lt;/h2&gt;

&lt;p&gt;The other advantage of running tests purely in isolation is that they’re fast. Very fast. When I’m coding Rails apps these days, thanks to advice from &lt;a href=&quot;http://twitter.com/coreyhaines&quot;&gt;Corey Haines&lt;/a&gt; I’m running a &lt;code&gt;spec_no_rails&lt;/code&gt; folder which runs independently from the rest of my Rails app. Rails apps by default epitomise this problem: default model tests exercise the whole system from the database up. By running your tests independently you’re not having to clean the database or start Rails each time you run your tests, which means that much of your interesting code can be tested in under a second. &lt;a href=&quot;http://twitter.com/garybernhardt&quot;&gt;Gary Bernhardt&lt;/a&gt; has more information on how to set this up in his excellent &lt;a href=&quot;http://destroyallsoftware.com&quot;&gt;Destroy All Software&lt;/a&gt; screencast series.&lt;/p&gt;

&lt;h2 id=&quot;what-im-not-saying&quot;&gt;What I’m not saying&lt;/h2&gt;

&lt;p&gt;This isn’t an argument for or against Mocks or Stubs. Either technique can be used successfully to generate clean code. It’s an argument about only exercising the code under test, and leave the rest of the system to take care of itself. The important thing is that you &lt;em&gt;don’t exercise your collaborators:&lt;/em&gt; whether you check they’ve received messages or simply stub them to return input doesn’t matter.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Don’t forget end-to-end tests.&lt;/em&gt; These are very important for business acceptance and for ensuring basic functionality. The important thing is to ensure that you’re being intentional about your end-to-end tests and ensure your unit tests are not end-to-end tests by accident.&lt;/p&gt;

&lt;p&gt;Take a good look at the test code for a project you recently worked on. You don’t need to look at the production code yet: notice that I’ve not included any production code in these examples. You shouldn’t need to see it to know whether it’s of good quality or not: you can tell that by reading the tests.&lt;/p&gt;

&lt;p&gt;Which is the most annoying or bulky part of your test code? Are your tests deceiving you about what they’re testing? How could you improve the code to make this test code easier to maintain?&lt;/p&gt;
</content></entry><entry><title>How to get Spork working NOW on Rails 3, Rspec 2 and Cucumber</title><category term='rails'/><category term='ruby'/><category term='rspec'/><category term='spork'/><category term='cucumber'/>    <author>
      <name>Chris Parsons</name>
      <email>chrismdp@gmail.com</email>
    </author>
<link href='http://chrismdp.com/2010/11/getting-spork-working-now-on-rails-3-rspec-2-and-cucumber'/><updated>2010-11-16T21:41:57+00:00</updated><id>http://chrismdp.com/2010/11/getting-spork-working-now-on-rails-3-rspec-2-and-cucumber</id><content type='html'>&lt;p&gt;I’ve spent the evening trying to get &lt;a href=&quot;https://github.com/timcharper/spork&quot;&gt;Spork&lt;/a&gt; to work with Rails 3 and RSpec 2. I’ve never felt the need for it before, but the Rails 3 start up time is fairly hefty and I’m crying out for the extra seconds more than ever.&lt;/p&gt;

&lt;p&gt;It’s not that tricky, thankfully, and the following steps should see you running faster specs and features in no time.&lt;/p&gt;

&lt;h2 id=&quot;rspec-2&quot;&gt;RSpec 2&lt;/h2&gt;

&lt;p&gt;Follow these instructions to get RSpec 2 working:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Install Spork into your Gemfile, and update rspec to 2.1:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;{% highlight ruby %}
gem “spork”, :git =&amp;gt; “git://github.com/chrismdp/spork.git”
gem “rspec-rails”, ‘&amp;gt;= 2.1.0’
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;You’ll need &lt;a href=&quot;http://github.com/chrismdp/spork&quot;&gt;my fork of Spork&lt;/a&gt; for a quick patch to the latest release candidate of Spork.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Add &lt;code&gt;--drb&lt;/code&gt; on a new line in your .rspec file:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you don’t have the .rspec file, create it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Modify your spec_helper.rb:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You could follow the installation instructions, but not everything is relevant to Rails 3 and Rspec 2. It’s pretty simple anyway: add “require ‘spork’” to the top of your spec_helper.rb file, and put everything else inside spec_helper.rb inside a Spork.pre_fork do … end block:&lt;/p&gt;

&lt;p&gt;{% highlight ruby %}
require ‘spork’&lt;/p&gt;

&lt;p&gt;Spork.prefork do
  ENV[“RAILS_ENV”] ||= ‘test’
  require File.expand_path(“../../config/environment”, &lt;strong&gt;FILE&lt;/strong&gt;)
  require ‘rspec/rails’
  …
end
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;That should be it. To start up the server, run:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
$ bundle exec spork
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;…and then try running a spec or two. The following command takes about a second on my machine now, whereas it used to take about ten seconds!&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
$ bundle exec rspec spec/controllers/sessions_controller_spec.rb
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;cucumber&quot;&gt;Cucumber&lt;/h2&gt;

&lt;p&gt;It’s important to note that for more than about 10-20 scenarios, Spork is &lt;em&gt;slower&lt;/em&gt; than running cucumber normally. Therefore only turn it on for a few profiles, such as autotest (but not autotest-all), wip, etc.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Modify your cucumber.yml file:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;{% highlight yaml %}
wip: –drb -tags @wip:3 –wip features
autotest: –drb –color –format progress –strict
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Leave ‘autotest-all’ and ‘default’ alone.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Modify your features/support/env.rb:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is just the same process as with the spec_helper.rb file for RSpec:&lt;/p&gt;

&lt;p&gt;{% highlight ruby %}
require ‘spork’&lt;/p&gt;

&lt;p&gt;Spork.prefork do
  ENV[“RAILS_ENV”] ||= “test”
  require File.expand_path(File.dirname(&lt;strong&gt;FILE&lt;/strong&gt;) + ‘/../../config/environment’)
  require ‘cucumber/formatter/unicode’ # Remove this line if you don’t want Cucumber Unicode support
  require ‘cucumber/rails/rspec’
  …
end
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Again, that should be it. Run the follow to try it out:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
$ bundle exec spork cucumber
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Now try running a single feature in rerun or autotest mode. I’m getting 20% speedups for about 10 scenarios.&lt;/p&gt;

&lt;h2 id=&quot;using-them-together&quot;&gt;Using them together&lt;/h2&gt;

&lt;p&gt;The RSpec and Cucumber versions of spork use different ports, so there’s no problem running them together. Normally I run both in the same terminal window, one as a background process:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
$ bundle exec spork cucumber &amp;amp; bundle exec spork
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Then I run autotest in another window.&lt;/p&gt;

&lt;h2 id=&quot;how-do-i-use-this&quot;&gt;How do I use this?&lt;/h2&gt;

&lt;p&gt;I’m really liking this setup. It makes rapid TDD possible again, even when dealing with fairly slow tests. &lt;/p&gt;

&lt;p&gt;Of course, we should be doing all we can to get the speed of our tests as high as possible: slow tests are a type of code smell. However, infrastructure load time is unavoidable and cutting it out is full of all kinds of win.&lt;/p&gt;

&lt;p&gt;Use this setup with &lt;a href=&quot;https://github.com/grosser/autotest&quot;&gt;autotest&lt;/a&gt; and &lt;a href=&quot;https://github.com/svoop/autotest-growl&quot;&gt;autotest-growl&lt;/a&gt; for maximum win. Autotest has come a long way recently: there’s a lightweight alternative to ZenTest now, and easy growl support. Cutting out even the ‘Oh, I should run my tests now step’ totally nails your debug cycle: not sure it gets much tighter than that.&lt;/p&gt;

&lt;h2 id=&quot;update-even-more-speed&quot;&gt;UPDATE: Even more speed!&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://opinionatedprogrammer.com/&quot;&gt;Jo Liss&lt;/a&gt; got in touch: she’s made some performance gains by skipping the “bundle exec” and requiring a few extra files in the prefork block. Read about what she has to say &lt;a href=&quot;http://opinionatedprogrammer.com/2011/02/profiling-spork-for-faster-start-up-time/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</content></entry></feed>
