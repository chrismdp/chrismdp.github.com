---
layout: nil
---
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Chris Parsons: posts tagged c++</title>

  <link href="http://chrismdp.com/"/>
  <updated>2012-04-16T12:20:48+01:00</updated>
  <id>http://chrismdp.com/tag/c++</id>
  <author>
    <name>Chris Parsons</name>
    <email>chrismdp@gmail.com</email>
  </author>
<entry><title>A fresh take on DCI with C++ (with example)</title><category term='coding'/><category term='c++'/><category term='craftsmanship'/><category term='dci'/><category term='sol trader'/><link href='http://chrismdp.com/2012/04/a-fresh-take-on-dci-with-c-plus-plus'/><updated>2012-04-16T12:20:48+01:00</updated><id>http://chrismdp.com/2012/04/a-fresh-take-on-dci-with-c-plus-plus</id><content type='html'>&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can now do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;!
&lt;/div&gt;

I've been reading quite a lot about [DCI](http://en.wikipedia.org/wiki/Data,_Context,_and_Interaction) recently, both from the point of view of the [original paper](http://heim.ifi.uio.no/~trygver/2009/commonsense.pdf) published in 2009 and various other sources on the Internet. There's been a discussion around beginning to use it with Ruby on Rails, but at the moment I'm more interested in how to apply the principles to [Sol Trader](http://soltrader.net) in C++.

## What is DCI?

DCI stands for Data, Context and Interaction. It places behaviour at the forefront of your design by setting the stage for a particular use-case through Context objects, and having all the behaviour exist in Role objects seperate to your basic persisted Data objects.  For example, you might have an `Account` &quot;Data&quot; class, which just contains the data representation and basic methods such as `IncrementBalance` and `DecrementBalance`. You'd then have a use-case `TransferMoney` with two roles: `SourceAccount` and `DestinationAccount`. These roles would be played by `Account` objects, but the behaviour of the objects would depend on the roles they play in the use case. The behaviour of the system is therefore captured in one place: it's in the interaction between the roles within a particular use case context, rather than being spread all over different data classes.

This design paradigm is very interesting. We've known for a while that if you mix persistence and behaviour you'll get into somewhat of a mess with your code design after a while. What's new is that whilst we avoid mixing persistence and behaviour, we still often mix *data* and behaviour: that is, we put code describing what the object *does* in the same class as the code which describes what it *is*. This is a subtle violation of the [Single Responsibility Principle](http://en.wikipedia.org/wiki/Single_responsibility_principle); I hadn't noticed this violation before reading about DCI.

The  proponents of DCI advocate injecting methods describing the Role in any given use case directly into the data object when setting the use case up. This is easy in a language like Smalltalk or Ruby, but is considerably harder in C++. What approach should we take in C++ with Roles? Is this the right approach at all?

## The templating method for injection of role behaviour

One way around this it to use templates: subclass your Data objects with a templated class which includes the roles you want the object to play. For example, to take our account example earlier, we could have:

{% highlight cpp %}

    class DestinationAccount {
    public:
      virtual ~DestinationAccount() {}

      virtual void DepositMoney(int amount) = 0;
    };

    template &lt;class DataClass&gt; class DestinationAccountCollaborator :
      public DataClass, public DestinationAccount
    {
      DestinationAccountCollaborator(int id) : DataClass(id) {}
      virtual void DepositMoney(int amount) {
        DataClass::IncrementBalance(amount);
      };
    };
{% endhighlight %}

We would also have a similar set up for `SourceAccount`. This way we can pass a pointer to the `DestinationAccount` interface to our Context to set up the use case:

{% highlight cpp %}

    class TransferMoneyContext {
      DestinationAccount&amp; _dest;
      SourceAccount&amp; _source;
    public:
      TransferMoneyContext(DestinationAccount&amp; dest,
        SourceAccount&amp; source) : _dest(dest), _source(source) {}
    };

    ...

    DestinationAccountCollaborator&lt;Account&gt; dest(accountNumberId);
    SourceAccountCollaborator&lt;Account&gt; source(sourceAccountId);
    TransferMoneyContext context(dest, source);

{% endhighlight %}

The DataClass would then instantiate itself from the account id and the role contains the description of the behaviour.

In practice however, I found this extremely unwieldy. My data classes all had slightly different interfaces, especially as many of them served as API endpoints. The templates ended up being 'clever' code - they saved very little space at the expense of a good amount of readability. The whole point of DCI is to try and capture behaviour in the Role classes to improve readability and create a cleaner design, and this approach wasn't serving that purpose. There might be better ways of doing it, and I'd be grateful if you'd let me know if you know of a better approach.

## The composition method for roles

The DCI literature teaches us to inject behaviour into the Data objects, to prevent [self schizophrenia](http://en.wikipedia.org/wiki/Schizophrenia_(object-oriented_programming)). For complex use cases, I can see that it would be useful for roles to have access to the methods defined on data objects: but perhaps it would be better to have simpler use cases and have roles only be defined in terms of other roles? In that instance, the roles can simply compose the data objects and expose whichever methods seem appropriate to the other roles in the use case.

## A worked example

As an example, consider this use case that came up recently in Sol Trader: I have a `MarketListing` object which contains a particlar `Good` (such as Grain, or Water) available at a certain price. The GUI displays a list of these `MarketListing` objects in a table format. Whenever a change was detected to any of the listings I would clear the table and reconstruct the gui elements, rather than updating the original elements.

This worked fine, until I realised that the GUI library I'm using did not expect GUI elements to be deleted and recreated under the mouse cursor, and wouldn't fire &quot;click&quot; events correctly at the newly created elements.

Therefore I needed a way to synchronise the GUI table with the `MarketListings` somehow, add new listings that have appeared, update the text of any existing listings, and remove old elements that refer to listings that no longer exist in the set. I decided to try to implement this using DCI, using the composition approach to roles I've discussed.

The use case is quite simple:

* For each source data structure:
* Does it already exist? If so, update the elements
* If not, create new elements
* Remove any elements that weren't checked this run

After writing some tests, I started with the following context object:

{% highlight cpp %}

    class RowUpdater {
      role::TableSource&amp; _source;
      role::TableRepresentation&amp; _table;
      int _timestamp;
    public:
      RowUpdater(role::TableSource&amp; source, role::TableRepresentation&amp; table) : _source(source), _table(table), _timestamp(0) {}

      void execute();
      void checkRow(void const* rowIdentifier);
    };
{% endhighlight %}

Note the two role objects, `TableSource` and `TableRepresentation`. I'll come back to those later.

`execute()` and `checkRow()` were defined like this:

{% highlight cpp %}

    void RowUpdater::execute() {
      _timestamp = SDL_GetTicks(); // Could be any unique number
      _source.enumerateRows(boost::bind(&amp;RowUpdater::checkRow, this, _1));
      _table.removeUncheckedRows(_timestamp);
    }

    void RowUpdater::checkRow(void const* rowIdentifier) {
      if (_table.rowExists(rowIdentifier))
        _table.updateRowFor(rowIdentifier, _source, _timestamp);
      else
        _table.addRowFor(rowIdentifier, _source, _timestamp);
    }

{% endhighlight %}

(In C++ you can't easily enumerate, so I used boost::bind to call `checkRow()` on each row in the `_source` object.)

This code is beautifully simple, and very close to the pseudo code I wrote earlier.

### Implementing TableRepresentation

What does this context require of the roles? Here are the methods needed for `TableRepresentation`, taken directly from the context above:

{% highlight cpp %}

    bool rowExists(void const* id);
    void updateRowFor(void const* id, TableSource const&amp; source, int timestamp);
    void addRowFor(void const* id, TableSource const&amp; source, int timestamp);
    void removeUncheckedRows(int timestamp);

{% endhighlight %}

This object is created with the data it needs to manipulate: in this case a `Rocket::Core::Element` object. When it needs to update elements, it is passed a `TableSource` role to give it the relevent data. Here's some of the code for the `addRowFor()` method:

{% highlight cpp %}

    void TableRepresentation::addRowFor(void const* id, TableSource const&amp; source, int timestamp) {
      Rocket::Core::Element* entry = _element-&gt;GetOwnerDocument()-&gt;CreateElement(&quot;li&quot;);
      entry-&gt;SetAttribute(&quot;good&quot;, (void*)id);
      std::vector&lt;std::string&gt; columnList;
      source.fetchColumnList(columnList);
      std::vector&lt;std::string&gt;::iterator it = columnList.begin();
      for(; it != columnList.end(); it++) {
        ChildContentTag(entry, &quot;div&quot;, it-&gt;c_str(), source.rowFor(it-&gt;c_str(), id).c_str());
      }
      _element-&gt;AppendChild(entry);
      entry-&gt;RemoveReference();
      entry-&gt;SetAttribute(&quot;updated_at&quot;, timestamp);
    }

{% endhighlight %}

There's a lot of noise here, but note the use of `source`. The code creates a new `li` element, gets the column list from the source and then asks the source for the string data for a particular row using `rowFor()`. The roles are interacting to provide the behaviour of the use case.

### Implementing TableSource

`TableSource` needed to be an interface in the end to manage both viewing a series of `MarketListings` and also a player `Inventory`. Here are the methods:

{% highlight cpp %}

    virtual void enumerateRows(boost::function&lt;void(const void*)&gt; action) = 0;
    virtual std::string rowFor(std::string const&amp; key, void const* id) const = 0;
    virtual void fetchColumnList(std::vector&lt;std::string&gt;&amp; list) const = 0;

{% endhighlight %}

For a `MarketListing`, here's the implementation of the key methods that the `TableRepresentation` needs:

{% highlight cpp %}

    void CommodityMarketTableSource::fetchColumnList(std::vector&lt;std::string&gt;&amp; list) const {
      list.push_back(&quot;name&quot;);
      list.push_back(&quot;price&quot;);
      list.push_back(&quot;quantity&quot;);
    }

    std::string CommodityMarketTableSource::rowFor(std::string const&amp; key, void const* id) const {
      MarketListing const* listing = _market.listings()[(Good const*)id];
      std::stringstream stream;
      if (key == &quot;name&quot;)
        return listing-&gt;name();
      if (key == &quot;price&quot;) {
        stream &lt;&lt; &quot;$&quot;;
        stream &lt;&lt; listing-&gt;price().amount();
        return stream.str();
      }
      if (key == &quot;quantity&quot;) {
        stream &lt;&lt; listing-&gt;amountAtThisPrice();
        return stream.str();
      }
    }
{% endhighlight %}

The player `Inventory` table source code is very similar.

### Tying it together

How do I use this thing? Inside my controller for updating the GUI window, I do the following:


{% highlight cpp %}

    void MarketController::syncInventory() {
      Rocket::Core::Element* entries = _planetWindow-&gt;GetElementById(&quot;inventory&quot;)-&gt;GetLastChild();

      gui::role::TableRepresentation tableRole(entries);
      gui::role::InventoryTableSource sourceRole(_inventory);
      gui::RowUpdater(sourceRole, tableRole).execute();
    }

    void MarketController::syncMarketListings() {
      Rocket::Core::Element* entries = _planetWindow-&gt;GetElementById(&quot;market&quot;)-&gt;GetLastChild();

      role::TableRepresentation tableRole(entries);
      role::CommodityMarketTableSource sourceRole(_market);
      gui::RowUpdater(sourceRole, tableRole).execute();
    }

{% endhighlight %}

In each case the `TableRepresentation` is the same, with a different target element, and the source is different depending on what I want to show for that table.

## In conclusion

I could have simply used a list of `MarketListing` objects instead of my `TableSource`, and manipulated the `Element` objects in the GUI directly. That's what I did at first, but this approach gives me a number of advantages:

* The code for enumerating rows, and exposing certain data to to the GUI is kept out of `MarketListing`, which is great: it only makes sense in this Context which is exactly what a role is for.
* The actual guts of the synchronisation code is kept in the Context. I'm not sure this is the best place, but it's great to have it in one place.
* It was trivial to add a `role::InventoryDataSource` object: in another 30 minutes or so I had TDDed out the display of inventories of goods using the same Context and slightly different roles.
* I could potentially replace the `TableRepresentation` with anything which we need to sync lists of tabular data with.

I tested this using some real `CommodityMarket` objects, which contain `MarketListing` objects: I poked new goods into them and checked the elements were being created and removed successfully.

Here's a screenshot of the market at work:

![Sol markets](/files/sol-trader-market-1.png)

In summary, I'm very pleased with how this turned out. There is a bit more code than just hard wiring it, but all my behaviour is in one place, and I've not loaded my market and goods classes with yet more functionality. I'm now looking for other use cases to implement using a similar method, as I move on to building a realistic (as opposed to random) economy.

How do you like my approach to DCI? Have I missed something profound, or how could I improve my approach?
</content></entry><entry><title>Sol Trader: on lighting</title><category term='products'/><category term='c++'/><category term='code'/><category term='opengl'/><category term='sol trader'/><category term='game development'/><category term='lighting'/><link href='http://chrismdp.com/2012/02/sol-trading-lighting'/><updated>2012-02-14T22:56:43+00:00</updated><id>http://chrismdp.com/2012/02/sol-trading-lighting</id><content type='html'>A quick update on the lighting code I've been working on. Now that I have normal maps and per-pixel bump mapping working, I can turn these:

![ship-texture-1](/files/sol-trader-lighting-1.png)
![ship-texture-2](/files/sol-trader-lighting-2.png)

Into this:

![ship-texture-3](/files/sol-trader-lighting-3.png)
![ship-texture-4](/files/sol-trader-lighting-4.png)

Check out how the ship appears lit from each side. It looks even better as you see it moving. Hey presto: a realistic 3D effect with only two triangles rendered.

All I'm using is this simple GLSL fragment shader:

{% highlight c %}

    void main() {
      vec4 color = texture(baseTexture, uv);
      vFragColor = vertColor * color;
      float alpha = vFragColor.a;

      if (alpha &gt; 0.0 &amp;&amp; useNormal) {
        vec3 lightDirection = normalize(vec3(0.2, 0.2, 0.0));
        vec4 normal = normalize(texture(normalTexture, uv) * 2.0 - 1.0);
        vec4 vEyeNormal = normalMatrix * normal;

        float diffuse = max(0.0, dot(vEyeNormal.xyz, lightDirection));
        vFragColor *= (diffuse * 3);
        vFragColor.a = alpha;
      }
    }

{% endhighlight %}

[GLSL](http://en.wikipedia.org/wiki/GLSL) is great.
</content></entry><entry><title>Effective bloom in OpenGL for Sol Trader</title><category term='products'/><category term='c++'/><category term='code'/><category term='opengl'/><category term='bloom'/><category term='sol trader'/><category term='game development'/><link href='http://chrismdp.com/2012/02/effective-bloom-in-open-gl-for-sol-trader'/><updated>2012-02-02T16:28:30+00:00</updated><id>http://chrismdp.com/2012/02/effective-bloom-in-open-gl-for-sol-trader</id><content type='html'>&lt;div class='notice'&gt;
  &lt;h2&gt;TL;DR&lt;/h2&gt;

  &lt;p&gt;Skip to the &lt;a href='#pictures'&gt;pictures&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;

I've been working on and off on [Sol Trader](http://soltrader.net) ([C++ version](/2012/01/why-i-switched-from-ruby-back-to-c-plus-plus/)) for about a month now. At the beginning of this week, I've been coded up an effective type formatting system using freetype2 natively with OpenGL, which is now in and showing even rather esoteric fonts nicely.

The second half of this week was spent adding on a bloom filter to the graphics engine.

## Bloom filtering: making your world stand out

A bloom filter causes bright areas of the image to 'take over' their surrounding area, simulating the high dynamic range of real light. It stops your game world from looking dull and flat and really makes it stand out. See [this article](http://www.gamasutra.com/view/feature/2107/realtime_glow.php) for some nice screenshots from Tron 2.0 - it can also be used for all sorts of glow and blur effects.

So how's it done? The trick is to render your scene to a texture, rather than to the screen. Once you've done that, you blur and downsample that texture a few times, and then display the results combined with the original texture.

Specifically, this is the process my bloom filter follows:

* Render to a texture
* Copy that texture to two more textures, one a quarter of the screen size, and one an eighth of the screen size.
* Blur the two smaller textures using gaussian blur. There are [clever techniques](http://prideout.net/archive/bloom/) which mean you only need six texture lookups to perform a 5x5 gaussian blur. Texture lookups are expensive, so it's worth doing as few as possible.
* Add all these textures together and add an exposure function to cause the white to saturate for strong color values.

Writing the initial bloom filter was fairly easy. Making it fast was *hard:* you have to work at combining the different aspects of the effect to get what you want, with the absolute minimum of effort for your graphics card. My first attempt ran at a paltry 27 frames a seconds, although it looked very nice: I eventually managed to get it to the point where it runs in roughly 150 frames per second and still looks 80% as good.

&lt;div name=&quot;pictures&quot;&gt;
  &lt;h2&gt;What's the result?&lt;/h2&gt;
&lt;/div&gt;

A picture is worth a thousand words, so here are three:

![bloom-1](/files/sol-trader-bloom-1.png)

![bloom-2](/files/sol-trader-bloom-2.png)

![bloom-3](/files/sol-trader-bloom-3.png)

I've deliberately upped the bloom exposure to show off the effect: it is much more obvious when it's moving. Hopefully you can see the volcanic eruptions on Venus are making the outline of the players' ship that much more hazy. The label of the planet also currently has the bloom effect applied: I'll be able to turn that off when I have a more functional GUI in place.

I plan to use this effect for all sorts of things: laser fire, explosions, you name it.

## Next...

I'm going to tackle the gui. I now have AI characters with names trading on Earth's main commodity market: it's time the player joins them in making trades.

&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can now do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;!
&lt;/div&gt;
</content></entry><entry><title>Switching Sol Trader from Ruby to C++: one week on</title><category term='products'/><category term='ruby'/><category term='c++'/><category term='code'/><category term='sol trader'/><category term='game development'/><link href='http://chrismdp.com/2012/01/switching-sol-trader-from-ruby-to-c-plus-plus-one-week-on'/><updated>2012-01-16T09:38:25+00:00</updated><id>http://chrismdp.com/2012/01/switching-sol-trader-from-ruby-to-c-plus-plus-one-week-on</id><content type='html'>Well, I didn't quite expect that. My [previous post](/2012/01/why-i-switched-from-ruby-back-to-c-plus-plus/) about switching [Sol Trader](http://soltrader.net) development from Ruby back to C++ caused [quite a storm](http://news.ycombinator.com/item?id=3440596).

Not being used to making waves on the mainstream Internet, I naively attempted to dive in and read and respond to every comment. It appears that feedback from the Internet at large tends towards the negative, so after a few hours I was feeling pretty discouraged, and only continued replying to some of the constructive feedback. Sorry if you didn't get a response.

I have a few more comparisons between Ruby and C++ which I'd like to share.

* *I'm finding myself reinventing the wheel more.* In Ruby-land I found third-party code easier to read, easier to install and easier to use. Trying to use someone else's library is C++ is harder. Often people don't seem to write automated tests, which strongly recommends me against using them. I'm also concerned that new libraries might introduce hidden memory leaks which will waste me time massively when I come to hunt them down. I appreciate people don't release their code just for me, so I'm not complaining: I've just found it more difficult to trust third-party code. I hope to try and fix this tendency by releasing large extractions from my project as libraries in the future.

* *Boost is awesome.* One notable exception to the above concern is the wonderful [Boost](http://boost.org) library suite. There is a library for almost everything you might need there, and the quality is very high. I'm already using the [Signals2](http://www.boost.org/libs/signals2) library for notifications (following the [Observer pattern](http://en.wikipedia.org/wiki/Observer_pattern)) and I plan to use the [Serialization](http://www.boost.org/libs/serialization) library for saving and loading games.

* *What to test?* The testing profile of my C++ code is different to my Ruby code. Thanks to strong typing, my tests fail for longer during the 'red' stage, so I find I have to write fewer edge cases. There are only so many ways C++ types can fit together, whereas Ruby objects can be combined in any way you like. I'm not sure I've hit on the right level of coverage yet: I'm not writing any tests for the more visual parts of Sol Trader yet and I'd like to consider how to.

* *I'm using a classist approach to testing.* In C++ I've tended to favour a [classical approach to TDD](http://martinfowler.com/articles/mocksArentStubs.html): that of testing a few small classes together from the outside using the public interface. Where I'm [coding to interfaces](http://stackoverflow.com/a/384067/1073735) I'm able to stub out that interface by inheriting from it in my test, but I'm not doing that often. Mostly I'm following my nose and attempting to keep my classes small and my collaborations few. I don't get all the design signals from my tests that I would like, but in my view that's better than exposing the internals of my class to the tests: that just complicates it unnecessarily. C++ is already difficult to read.

* *Prototyping complex class structures in Ruby first is really useful.* I've often benefited from having an existing Ruby class structure to take as my lead when writing C++. Those subsystems that I'd already written in Ruby were at least twice as fast to write. Rather than typing, or getting past the syntax, I've found [learning to be the constraint](http://dannorth.net/2010/08/30/introducing-deliberate-discovery/) in a number of coding situations. I'm not sure I'd always write in Ruby first, but in a case where I was really stuck and wanted to explore possible options, I might consider a rapid Ruby prototype over [CRC card design](http://en.wikipedia.org/wiki/Class-responsibility-collaboration_card), for example.

I'll continue to post my learnings as I collect them.

&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can now do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;!
&lt;/div&gt;
</content></entry><entry><title>Why I switched from Ruby back to C++</title><category term='products'/><category term='ruby'/><category term='c++'/><category term='code'/><category term='sol trader'/><category term='game development'/><link href='http://chrismdp.com/2012/01/why-i-switched-from-ruby-back-to-c-plus-plus'/><updated>2012-01-08T20:21:41+00:00</updated><id>http://chrismdp.com/2012/01/why-i-switched-from-ruby-back-to-c-plus-plus</id><content type='html'>&lt;div class='notice'&gt;
  &lt;b&gt;UPDATE:&lt;/b&gt; This post was pretty popular. I've posted a followup &lt;a href=&quot;/2012/01/switching-sol-trader-from-ruby-to-c-plus-plus-one-week-on/&quot;&gt;here&lt;/a&gt;.
&lt;/div&gt;

After two months of Sol Trader development in Ruby, I took a difficult decision last Wednesday morning: I've decided to rewrite the game code from scratch in C++. Let me explain my reasons.

&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can now do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;!
&lt;/div&gt;

## Why I did it

* *Slow frames:* When working with Ruby, I use the excellent [Gosu](https://github.com/jlnr/gosu) library to do all my game specific coding. This initially worked great, but occasionally I'd just get slow frames coming up. My game is timed to run at 60 frames per second, which means that each frame should take no more than 16.67ms to run. Yet every so often my profiling would come up with a frame that would take 25ms or 45ms for no discernible reason. I just couldn't find the issue here: I turned every sub system in the game off. I disabled garbage collection. I hacked my slow frame detection code into the simplest gosu sample I could find, and they still existed. I didn't feel like I could quite trust the stack to deliver the framerate I needed, and I hadn't yet put in half the features I wanted to.

* *Object explosion when bridging to C:* A lot of the libraries I was using were written in C, and therefore there was several thousand objects (mostly floats) being created each frame to act as a bridge between Ruby and C code. It feels like that that CPU time should be better spent in the AI improving the quality of the simulation, or on better effects, rather than loading the garbage collection with an unnecessary burden.

* *Ease of packaging and distribution:* I feel like packaging is going to be a lot easier. I'm not too bothered about hiding the source code: I may well do that anyway to purchasers of the game. It's the running on Windows I'm worried about: from my research it feels like it's going to take some effort to push the game out on a non-Unix platform. And with a video game, releasing on Windows is a must.

* *Manual memory management for performance:* The garbage collection is still too stuttery under MRI (even with Ruby 1.9.3, which is a huge improvement on what's gone before) - it still stops the world each time. I looked at other implementations, and even considered learning all about garbage collection to help improve Ruby myself, but then realised that getting royally distracted wouldn't help me ship a working game.

## What do I miss about Ruby?

* *I miss using RSpec hugely:* There are ways of doing [testing of C programs using RSpec](http://benmabey.com/2007/09/09/bdd-your-c.html) but it doesn't feel like I want to wrap each of my C++ classes with a SWIG interface just to check they're working. I may still do this for some form of Cucumber testing, I'm not sure. I'm using [UnitTest++](http://unittest-cpp.sourceforge.net/) for my testing at the moment, which is very lightweight and good enough for my purposes.

* *Duck-typing:* defining interfaces for everything is a pain in the backside, although it does force you to think more clearly about the roles of your classes.


* *Easy mockist testing:* There's no built in reflection in C++ so it also makes you have to code to interfaces if you want to do any mockist testing. I'm mostly returning to a classist style of testing with small well defined groups of classes being tested at once. It's not a perfect system and I still have much learning to do here.

* *Terseness of syntax:* There's just a lot more characters to type, and a lot more ceremony for each class. This tempts you to larger classes and methods, which I'm resisting at the moment. I need to take the time to set up [c.vim](http://www.vim.org/scripts/script.php?script_id=213) exactly how I want it.

Funnily enough, I don't miss the automatic memory management: I like having that level of control. Old habits die hard.

## So how far have I got?

Thankfully, it's not a complete rewrite as I'd already done a lot of thinking about the architecture and a lot of the basic classes translate directly over.  I worked really hard at the end of last week and got a lot done:

* I put in [SDL](http://www.libsdl.org) to build the basic game framework: hopefully building on Windows will be a snap. I plan to have a working Windows build as soon as I can lay my hands on a cheap Windows 7 PC.
* Basic testing using UnitTest++, with tests that are compiled and run as part of the build process.
* Decoupled gameplay/physics updates from the graphical framerate using the techniques [here](http://gafferongames.com/game-physics/fix-your-timestep/). I have zero [temporal aliasing](http://en.wikipedia.org/wiki/Temporal_anti-aliasing) bugs right now, which makes for a super smooth 300+ FPS graphic loop with a fixed 60FPS physics loop.
* Re-implemented physics using [Chipmunk](http://chipmunk-physics.net/), the same library I used in Ruby, which made it very easy to switch over.
* Put in a brand new and much improved parallax-scrolled starfield.
* Added a basic controllable spacecraft, planets and jumpgates back in: the player can fly around as before and collide successfully with other objects.
* A simple particle system so the spacecraft give off exhaust smoke, and the jumpgates emit spooky purple mist.

Even with using OpenGL [immediate mode](http://en.wikibooks.org/wiki/OpenGL_Programming/GLStart/Tut3#Immediate_Mode) (this is a bad thing) and rendering 10000 stars each frame (very inefficient), and a throwing bunch of particles onscreen, I'm still getting 300+ FPS on my 2009 MacbookPro and only using 30MB of memory. That's satisfying.

*UPDATE:* By (very) popular demand, here's a screenshot. Be aware this is *three days work only*, and obviously not final artwork:

&lt;a href='/files/sol-trader-1.png'&gt;&lt;img src='/files/sol-trader-1.png' width='500'/&gt;&lt;/a&gt;

Next I plan to add back in jumping between different planetary orbits, and then work on a very basic 'person-level view', so that you can get out of your ship and walk around.

## Was it the right decision?

I'll know at the end of the project :) My feeling is though that it was the correct thing to do. Being really close to the metal will make it much easier to implement some of the really complex AI stuff I'd like to do later on. I already know C++ very well, and estimate it'll only delay me a week or two if I work hard. If I like, I can always bundle my project as a C++ library and control it from Ruby later on, but it's harder to go in the other direction.

What do you think? Did I make the right call?

&lt;div class='notice'&gt;
  If you'd like to purchase Sol Trader you can now do so at &lt;a href='http://soltrader.net'&gt;soltrader.net&lt;/a&gt;!
&lt;/div&gt;
</content></entry></feed>
